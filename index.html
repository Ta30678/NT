<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      http-equiv="Cache-Control"
      content="no-cache, no-store, must-revalidate"
    />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>ETABS 梁自動編號工具 v2.1</title>

    <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.1/dist/svg-pan-zoom.min.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap"
      rel="stylesheet"
    />

    <!-- CSS 樣式 - 已模組化拆分 -->
    <link rel="stylesheet" href="css/main.css" />
    <link rel="stylesheet" href="css/components.css" />
    <link rel="stylesheet" href="css/layout.css" />
    <link rel="stylesheet" href="css/svg-canvas.css" />
    <link rel="stylesheet" href="css/fullscreen.css" />
    <link rel="stylesheet" href="css/dialogs.css" />

    <!-- JavaScript 模組 - 模組化重構 -->
    <!-- 使用 getter/setter 橋接 window 變數，與原始代碼共享資料 -->
    <script type="module" src="js/main.js"></script>

  </head>
  <body>
    <div id="container">
      <h1>ETABS 梁自動編號工具</h1>

      <div class="control-area">
        <!-- 第一排：檔案選擇與選項 -->
        <div class="control-row">
          <div class="file-input-group">
            <label for="e2kFile" class="file-label">
              <svg
                width="20"
                height="20"
                viewBox="0 0 20 20"
                fill="none"
                style="margin-right: 8px"
              >
                <path
                  d="M13 2H6a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V7l-3-5z"
                  stroke="currentColor"
                  stroke-width="2"
                />
              </svg>
              請選擇 ETABS .e2k 檔案
            </label>
            <input
              type="file"
              id="e2kFile"
              accept=".e2k"
              style="display: none"
            />
            <span id="fileName" class="file-name-display">未選擇檔案</span>
          </div>
        </div>

        <!-- 第二排：主要操作按鈕 -->
        <div class="button-row">
          <button
            class="btn btn-secondary"
            id="configBtn"
            onclick="showGridConfig()"
            disabled
          >
            <svg
              width="18"
              height="18"
              viewBox="0 0 24 24"
              fill="none"
              style="margin-right: 6px"
            >
              <circle
                cx="12"
                cy="12"
                r="3"
                stroke="currentColor"
                stroke-width="2"
              />
              <path
                d="M12 1v6m0 6v6M5.6 5.6l4.2 4.2m4.4 4.4l4.2 4.2M1 12h6m6 0h6M5.6 18.4l4.2-4.2m4.4-4.4l4.2-4.2"
                stroke="currentColor"
                stroke-width="2"
              />
            </svg>
            設定規則並編號
          </button>
          <button
            class="btn btn-success"
            id="exportBtn"
            onclick="exportToExcel()"
            disabled
          >
            <svg
              width="18"
              height="18"
              viewBox="0 0 24 24"
              fill="none"
              style="margin-right: 6px"
            >
              <path
                d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"
                stroke="currentColor"
                stroke-width="2"
              />
              <polyline
                points="14,2 14,8 20,8"
                stroke="currentColor"
                stroke-width="2"
              />
            </svg>
            匯出 Excel
          </button>
          <button
            class="btn btn-autocad"
            id="exportJsonBtn"
            onclick="exportToJSONV2()"
            disabled
          >
            <svg
              width="18"
              height="18"
              viewBox="0 0 24 24"
              fill="none"
              style="margin-right: 6px"
            >
              <path
                d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M17 8l-5-5-5 5M12 3v12"
                stroke="currentColor"
                stroke-width="2"
              />
            </svg>
            匯出 AutoCAD
          </button>
        </div>

        <!-- 第三排：所有控制項在一行 -->
        <div
          class="filter-row"
          style="
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 0;
          "
        >
          <div style="display: flex; gap: 15px; align-items: center">
            <div class="filter-group">
              <label for="storySelector">樓層</label>
              <select
                id="storySelector"
                onchange="handleStoryChange()"
                disabled
              ></select>
            </div>
            <div class="filter-group">
              <label for="beamTypeSelector">類型</label>
              <select
                id="beamTypeSelector"
                onchange="handleStoryChange()"
                disabled
              >
                <option value="all">全部</option>
                <option value="main">大梁</option>
                <option value="secondary">小梁</option>
              </select>
            </div>
            <div class="filter-group">
              <label for="fontSizeInput">字體大小</label>
              <input
                type="number"
                id="fontSizeInput"
                value="14"
                min="1"
                max="72"
                step="1"
                style="
                  width: 60px;
                  padding: 8px 12px;
                  border: 1px solid var(--theme-border);
                  border-radius: 8px;
                  background-color: #ffffff;
                  color: var(--theme-text-primary);
                "
                onchange="updateFontSize()"
              />
            </div>
          </div>
          <div style="display: flex; gap: 10px">
            <button
              class="btn-process"
              onclick="toggleGridBubbleControlPanel()"
              style="padding: 8px 16px"
              title="Grid Line 顯示控制"
            >
              🎯 Grid
            </button>
            <button
              class="btn-process"
              onclick="openSearchMemberDialog()"
              style="padding: 8px 16px"
            >
              🔍 搜尋桿件 (Ctrl+F)
            </button>
            <button
              class="btn-process"
              onclick="toggleFullscreen()"
              style="padding: 8px 16px"
              title="全螢幕顯示"
            >
              <span id="fullscreen-icon-top">⛶</span> 全螢幕
            </button>
          </div>
          <!-- [新增] 狀態訊息區域（動態顯示） -->
          <div id="status-inline" style="display: none; width: 100%"></div>
        </div>
      </div>
      <div id="status" style="display: none"></div>

      <!-- 格線編號配置面板 -->
      <div id="grid-config-panel" style="display: none; margin-bottom: 20px">
        <div class="control-area" style="position: relative">
          <div
            style="
              display: flex;
              justify-content: space-between;
              align-items: center;
              margin-bottom: 15px;
            "
          >
            <h3 style="margin: 0">格線編號規則設定</h3>
            <button
              onclick="toggleGridConfigHelp()"
              style="
                min-width: 32px;
                width: 32px;
                height: 32px;
                border-radius: 50%;
                background-color: var(--theme-accent);
                color: white;
                border: none;
                font-size: 16px;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: all 0.2s ease;
                padding: 0;
                flex-shrink: 0;
              "
              onmouseover="this.style.backgroundColor='var(--theme-accent-hover)'"
              onmouseout="this.style.backgroundColor='var(--theme-accent)'"
              title="格線編號說明"
            >
              💡
            </button>
          </div>

          <!-- 編號選項 - 上下兩排黑色按鈕 -->
          <div
            style="
              display: flex;
              flex-direction: column;
              gap: 8px;
              margin-bottom: 15px;
            "
          >
            <!-- MIRROR 按鈕列 -->
            <div style="display: flex; gap: 10px; align-items: center">
              <button
                id="mirrorModeBtn"
                onclick="openMirrorSettingsModal()"
                style="
                  padding: 8px 16px;
                  font-size: 0.9em;
                  font-weight: 600;
                  background: #1e293b;
                  color: #ffffff;
                  border: none;
                  border-radius: 6px;
                  cursor: pointer;
                  min-width: 90px;
                "
              >
                MIRROR
              </button>
              <span
                id="mirrorStatusText"
                style="font-size: 0.85em; color: #1e293b; font-weight: 500"
              ></span>
            </div>
            <!-- FIXED 按鈕列 -->
            <div style="display: flex; gap: 10px; align-items: center">
              <button
                id="fixedLabelBtn"
                onclick="toggleFixedLabelMode()"
                style="
                  padding: 8px 16px;
                  font-size: 0.9em;
                  font-weight: 600;
                  background: #1e293b;
                  color: #ffffff;
                  border: none;
                  border-radius: 6px;
                  cursor: pointer;
                  min-width: 90px;
                "
              >
                FIXED
              </button>
              <!-- 固定編號摘要顯示 -->
              <div
                id="fixedLabelSummary"
                style="font-size: 0.85em; color: #1e293b; font-weight: 500"
              ></div>
            </div>
            <!-- 隱藏的 checkbox 用於保持相容性 -->
            <input
              type="checkbox"
              id="mirrorModeToggle"
              style="display: none"
            />
            <input
              type="checkbox"
              id="fixedLabelToggle"
              style="display: none"
            />
          </div>

          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px">
            <div
              style="display: flex; flex-direction: column; align-items: center"
            >
              <h4
                style="color: var(--theme-text-secondary); margin-bottom: 10px"
              >
                X 軸格線 (垂直方向)
              </h4>
              <div
                id="x-grid-config"
                style="max-height: 300px; overflow-y: auto; width: 100%"
              ></div>
            </div>
            <div
              style="display: flex; flex-direction: column; align-items: center"
            >
              <h4
                style="color: var(--theme-text-secondary); margin-bottom: 10px"
              >
                Y 軸格線 (水平方向)
              </h4>
              <div
                id="y-grid-config"
                style="max-height: 300px; overflow-y: auto; width: 100%"
              ></div>
            </div>
          </div>
          <div style="margin-top: 15px; text-align: right">
            <button class="btn-process" onclick="applyGridConfig()">
              套用設定並執行編號
            </button>
            <button class="btn-export" onclick="cancelGridConfig()">
              取消
            </button>
          </div>
        </div>
      </div>

      <!-- [修改] Grid Bubble 顯示控制 Modal -->
      <div
        id="grid-bubble-overlay"
        class="dialog-overlay"
        onclick="closeGridBubbleModal()"
        style="display: none"
      ></div>
      <div
        id="grid-bubble-control-panel"
        style="
          display: none;
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          z-index: 10002;
          background: var(--theme-surface);
          border: 1px solid var(--theme-border);
          border-radius: 12px;
          padding: 20px;
          box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
          min-width: 300px;
          max-width: 450px;
        "
      >
        <h3 style="margin-top: 0">🎯 Grid Line 顯示控制</h3>
        <p
          style="
            color: var(--theme-text-secondary);
            margin-bottom: 15px;
            font-size: 0.9em;
          "
        >
          💡 可以針對不同 Grid Line 系統開關顯示
        </p>
        <div
          style="display: flex; flex-wrap: wrap; gap: 15px; margin-bottom: 20px"
          id="grid-system-toggles"
        >
          <!-- 動態生成的開關將顯示在這裡 -->
        </div>
        <div style="display: flex; justify-content: flex-end">
          <button class="btn-export" onclick="closeGridBubbleModal()">
            關閉
          </button>
        </div>
      </div>

      <div id="output">
        <div id="drawing">
          <!-- 全螢幕控制器 -->
          <div id="fullscreen-controls">
            <div class="controls-group">
              <button onclick="previousFloor()" title="上一個樓層 (↑)">
                ↑ 上一層
              </button>
              <div class="floor-info">
                <span id="fullscreen-story-name">所有樓層合併</span>
              </div>
              <button onclick="nextFloor()" title="下一個樓層 (↓)">
                ↓ 下一層
              </button>
            </div>
            <div class="controls-group">
              <select
                id="fullscreen-story-selector"
                onchange="handleFullscreenStoryChange()"
              >
                <option value="all">All Floors</option>
              </select>
              <span class="keyboard-hint">↑↓ 切換樓層 | Esc 離開全螢幕</span>
            </div>
            <button onclick="toggleFullscreen()">✕ 離開全螢幕</button>
          </div>

          <div
            style="
              display: flex;
              justify-content: space-between;
              align-items: center;
              margin-bottom: 10px;
            "
          >
            <h3 style="margin: 0">
              結構平面圖 (<span id="plan-story-name">所有樓層合併</span>)
            </h3>
            <button
              onclick="toggleHelpDialog()"
              style="
                min-width: 32px;
                width: 32px;
                height: 32px;
                border-radius: 50%;
                background-color: var(--theme-accent);
                color: white;
                border: none;
                font-size: 16px;
                font-weight: bold;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: all 0.2s ease;
                padding: 0;
                flex-shrink: 0;
              "
              onmouseover="this.style.backgroundColor='var(--theme-accent-hover)'"
              onmouseout="this.style.backgroundColor='var(--theme-accent)'"
              title="選取功能說明"
            >
              ?
            </button>
          </div>
          <div
            id="help-info-box"
            style="
              display: none;
              margin-bottom: 10px;
              padding: 10px;
              background: var(--theme-bg);
              border-radius: 8px;
              font-size: 0.9em;
              color: var(--theme-text-secondary);
            "
          >
            <strong style="color: var(--theme-accent)"
              >💡 選取功能說明（類似 AutoCAD）：</strong
            ><br />
            • <strong>點擊梁</strong>：累加選擇（持續選取多個梁）<br />
            •
            <strong>拖曳</strong
            >：框選多個梁（左→右藍框完全包含，右→左綠框碰到即選）<br />
            • <strong>Shift + 點擊</strong>：取消選擇指定的梁<br />
            • <strong>Esc</strong>：清除所有選擇<br />
            • <strong>Enter</strong>：批量修改選中梁的編號 |
            <strong>Ctrl+F</strong>：搜尋桿件
          </div>
          <svg id="drawing-svg"></svg>
        </div>
      </div>
    </div>

    <!-- 梁編號編輯對話框 (移到 container 外面，相對於整個視窗定位) -->
    <div
      id="beam-edit-dialog"
      style="
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 10002;
        background: var(--theme-surface);
        border: 1px solid var(--theme-border);
        border-radius: 12px;
        padding: 20px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        min-width: 400px;
      "
    >
      <h3 style="margin-top: 0">編輯梁編號</h3>
      <div style="margin-bottom: 15px">
        <label
          style="
            display: block;
            margin-bottom: 5px;
            color: var(--theme-text-secondary);
          "
          >ETABS 編號:</label
        >
        <input
          type="text"
          id="edit-etabs-name"
          readonly
          style="
            width: 100%;
            padding: 8px;
            background: var(--theme-bg);
            border: 1px solid var(--theme-border);
            border-radius: 6px;
          "
        />
      </div>
      <div style="margin-bottom: 15px">
        <label
          style="
            display: block;
            margin-bottom: 5px;
            color: var(--theme-text-secondary);
          "
          >樓層:</label
        >
        <input
          type="text"
          id="edit-story"
          readonly
          style="
            width: 100%;
            padding: 8px;
            background: var(--theme-bg);
            border: 1px solid var(--theme-border);
            border-radius: 6px;
          "
        />
      </div>
      <div style="margin-bottom: 20px">
        <label
          style="
            display: block;
            margin-bottom: 5px;
            color: var(--theme-text-secondary);
          "
          >新編號:</label
        >
        <input
          type="text"
          id="edit-new-label"
          style="
            width: 100%;
            padding: 8px;
            border: 1px solid var(--theme-border);
            border-radius: 6px;
          "
          placeholder="輸入新的編號"
        />
      </div>
      <!-- [新增] 連動標準層選項 -->
      <div
        id="link-standard-floor-group"
        style="margin-bottom: 15px; display: none"
      >
        <label
          style="display: flex; align-items: center; gap: 8px; cursor: pointer"
        >
          <input type="checkbox" id="link-standard-floor" checked />
          <span>連動標準層</span>
        </label>
      </div>
      <div style="display: flex; gap: 10px; justify-content: flex-end">
        <button class="btn-export" onclick="closeBeamEditDialog()">取消</button>
        <button class="btn-process" onclick="saveBeamEdit()">儲存</button>
      </div>
    </div>
    <!-- 遮罩層 -->
    <div
      id="dialog-overlay"
      style="
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 10001;
      "
      onclick="closeBeamEditDialog()"
    ></div>

    <!-- 批量编辑对话框 -->
    <div
      id="batch-edit-overlay"
      class="dialog-overlay"
      onclick="closeBatchEditDialog()"
    ></div>
    <div id="batch-edit-dialog" class="batch-edit-dialog">
      <h3>批量編輯梁編號 (<span id="batch-count">0</span> 個)</h3>
      <div class="dialog-content">
        <div class="input-group">
          <label>新編號:</label>
          <input
            type="text"
            id="batch-new-label"
            placeholder="輸入新的編號 (例如: g1)"
          />
        </div>
        <div
          style="
            color: var(--theme-text-secondary);
            font-size: 0.9em;
            margin-top: 10px;
          "
        >
          提示: 所有選中的梁都會被改成相同的編號
        </div>
        <!-- [新增] 連動標準層選項 -->
        <div
          id="batch-link-standard-floor-group"
          style="margin-top: 15px; display: none"
        >
          <label
            style="
              display: flex;
              align-items: center;
              gap: 8px;
              cursor: pointer;
            "
          >
            <input type="checkbox" id="batch-link-standard-floor" checked />
            <span>連動標準層</span>
          </label>
        </div>
      </div>
      <div class="button-group">
        <button class="btn-export" onclick="closeBatchEditDialog()">
          取消
        </button>
        <button class="btn-process" onclick="saveBatchEdit()">確定修改</button>
      </div>
    </div>

    <!-- 搜尋桿件對話框 -->
    <div
      id="search-member-overlay"
      class="dialog-overlay"
      onclick="closeSearchMemberDialog()"
    ></div>
    <div
      id="search-member-dialog"
      style="
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 10002;
        background: var(--theme-surface);
        border: 1px solid var(--theme-border);
        border-radius: 12px;
        padding: 20px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        min-width: 450px;
        max-width: 600px;
      "
    >
      <h3 style="margin-top: 0">🔍 搜尋桿件</h3>
      <div style="margin-bottom: 15px">
        <label
          style="
            display: block;
            margin-bottom: 5px;
            color: var(--theme-text-secondary);
          "
          >輸入 ETABS 編號:</label
        >
        <div style="display: flex; gap: 10px">
          <input
            type="text"
            id="search-member-input"
            style="
              flex: 1;
              padding: 10px;
              border: 1px solid var(--theme-border);
              border-radius: 6px;
              font-size: 14px;
            "
            placeholder="例如: B65, B1, G2A..."
            onkeypress="if(event.key === 'Enter') searchMember()"
          />
          <button
            class="btn-process"
            onclick="searchMember()"
            style="padding: 10px 20px"
          >
            搜尋
          </button>
        </div>
      </div>
      <div
        id="search-results"
        style="
          margin-top: 15px;
          padding: 15px;
          background: var(--theme-bg);
          border-radius: 8px;
          max-height: 300px;
          overflow-y: auto;
        "
      >
        <div style="color: var(--theme-text-secondary); text-align: center">
          輸入 ETABS 編號並點擊搜尋
        </div>
      </div>
      <div
        style="
          display: flex;
          gap: 10px;
          justify-content: flex-end;
          margin-top: 15px;
        "
      >
        <button class="btn-export" onclick="closeSearchMemberDialog()">
          關閉
        </button>
      </div>
    </div>

    <!-- 固定編號設定對話框 -->
    <div
      id="fixed-label-overlay"
      class="dialog-overlay"
      onclick="closeFixedLabelModal()"
    ></div>
    <div
      id="fixed-label-dialog"
      style="
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 10002;
        background: var(--theme-surface);
        border: 1px solid var(--theme-border);
        border-radius: 12px;
        padding: 20px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        min-width: 500px;
        max-width: 700px;
      "
    >
      <h3 style="margin-top: 0">固定編號設定</h3>
      <p
        style="
          color: var(--theme-text-secondary);
          margin-bottom: 15px;
          font-size: 0.9em;
        "
      >
        💡 將特定尺寸的梁指定為固定編號（例如：樓梯梁 sb25×50 →
        g1），其他梁編號時會跳過這個號碼<br />
        • 斷面名稱不區分大小寫（sb25×50 和 SB25X50 相同）<br />
        • 固定編號請填寫完整編號（例如：g1, b1, ga1 等）
      </p>
      <div id="fixed-label-modal-rules">
        <div
          class="fixed-label-rule"
          style="
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
          "
        >
          <input
            type="text"
            id="fixedSectionModal"
            placeholder="梁斷面 (例如: sb25×50)"
            style="
              flex: 1;
              padding: 8px;
              border: 1px solid var(--theme-border);
              border-radius: 6px;
              background: var(--theme-bg);
            "
          />
          <span style="color: var(--theme-text-secondary)">→</span>
          <input
            type="text"
            id="fixedLabelModal"
            placeholder="完整編號 (例如: g1)"
            style="
              width: 150px;
              padding: 8px;
              border: 1px solid var(--theme-border);
              border-radius: 6px;
              background: var(--theme-bg);
            "
          />
          <button
            onclick="addFixedLabelRuleModal()"
            class="btn-process"
            style="padding: 8px 15px"
          >
            + 新增
          </button>
        </div>
        <div
          id="fixed-label-modal-list"
          style="max-height: 300px; overflow-y: auto"
        ></div>
      </div>
      <div
        style="
          display: flex;
          gap: 10px;
          justify-content: flex-end;
          margin-top: 20px;
        "
      >
        <button class="btn-export" onclick="closeFixedLabelModal()">
          關閉
        </button>
      </div>
    </div>

    <!-- MIRROR 對稱設定對話框 -->
    <div
      id="mirror-settings-overlay"
      class="dialog-overlay"
      onclick="closeMirrorSettingsModal()"
    ></div>
    <div
      id="mirror-settings-dialog"
      style="
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 10002;
        background: var(--theme-surface);
        border: 1px solid var(--theme-border);
        border-radius: 12px;
        padding: 20px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        min-width: 400px;
        max-width: 500px;
      "
    >
      <h3 style="margin-top: 0">⚖️ MIRROR 鏡像模式設定</h3>

      <!-- 啟用開關 -->
      <div
        style="
          display: flex;
          align-items: center;
          gap: 15px;
          margin-bottom: 20px;
          padding: 12px;
          background: var(--theme-bg);
          border-radius: 8px;
        "
      >
        <label style="font-weight: 600; color: var(--theme-text-primary)"
          >啟用鏡像模式</label
        >
        <label class="switch" style="margin-left: auto">
          <input
            type="checkbox"
            id="mirrorModeToggleInModal"
            onchange="toggleMirrorModeFromModal()"
          />
          <span class="slider"></span>
        </label>
        <span
          id="mirrorModeStatusInModal"
          style="font-size: 0.9em; min-width: 40px"
          >關閉</span
        >
      </div>

      <!-- 主要設定：及格分數、配對容許誤差 (只在啟用鏡像模式時顯示) -->
      <div id="mirrorSettingsSection" style="display: none">
        <p
          style="
            color: var(--theme-text-secondary);
            margin-bottom: 15px;
            font-size: 0.9em;
          "
        >
          • <b>及格分數</b>：對稱匹配分數需達到此值才會啟用鏡像編號<br />
          • <b>配對容許誤差</b>：鏡像梁配對時允許的中點距離誤差
        </p>
        <div
          style="
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
          "
        >
          <div style="display: flex; align-items: center; gap: 15px">
            <label
              for="symmetryPassScore"
              style="min-width: 120px; color: var(--theme-text-secondary)"
              >及格分數 (%)</label
            >
            <input
              type="number"
              id="symmetryPassScore"
              value="70"
              min="10"
              max="100"
              step="1"
              style="
                flex: 1;
                padding: 10px 12px;
                border: 1px solid var(--theme-border);
                border-radius: 8px;
                background-color: #ffffff;
                color: var(--theme-text-primary);
                text-align: center;
                font-weight: 600;
                font-size: 1.1em;
              "
              onchange="updateSymmetrySettings()"
              title="🖱️ 滾輪調整"
            />
          </div>
          <div style="display: flex; align-items: center; gap: 15px">
            <label
              for="matchingTolerance"
              style="min-width: 120px; color: var(--theme-text-secondary)"
              >配對容許誤差 (m)</label
            >
            <input
              type="number"
              id="matchingTolerance"
              value="0.80"
              min="0.01"
              max="2.00"
              step="0.01"
              style="
                flex: 1;
                padding: 10px 12px;
                border: 1px solid var(--theme-border);
                border-radius: 8px;
                background-color: #ffffff;
                color: var(--theme-text-primary);
                text-align: center;
                font-size: 1.1em;
              "
              onchange="updateSymmetrySettings()"
              title="🖱️ 滾輪調整"
            />
          </div>
        </div>
      </div>

      <div style="display: flex; gap: 10px; justify-content: flex-end">
        <button class="btn-export" onclick="closeMirrorSettingsModal()">
          關閉
        </button>
      </div>
    </div>

    <script>
      // [修改] 擴充AutoCAD模式縮放的初始尺寸常數
      // [已模組化] 常數定義 (INITIAL_*) 和 calculateOffset 已移至 js/config/constants.js
      // 由 main.js 掛載到 window，本地不再需要定義


      var panZoomInstance = null;
      var fullProcessedBeams = [];
      var fullDrawableBeams = [];
      var availableStories = [];
      var gridData = {};
      var storyOrderInfo = {};
      const TOLERANCE = 0.1;

      // [新增] 預覽模式用的全域變數
      // [新增] 預覽模式用的全域變數
      var previewFileContent = null;
      var previewJoints = null;
      var userGridConfig = null; // 使用者自訂的格線編號配置

      // [新增] 梁編輯功能用的全域變數
      var currentEditingBeam = null;

      // [新增] 固定編號設定
      var fixedLabelRules = []; // 儲存 { section: "sb25x50", label: "g1" }

      // [新增] 圈选功能的全域變數
      // [重構] 直接使用 window 作為命名空間，確保模組和原始代碼共享同一份資料
      // 注意：Set 物件是引用類型，可以正確同步
      // [新增] 圈选功能的全域變數
      // [重構] 直接使用 window 作為命名空間，確保模組和原始代碼共享同一份資料
      // 注意：Set 物件是引用類型，可以正確同步
      var isSelecting = false;
      var selectionStart = null;
      var selectionRect = null;
      var selectedBeams = new Set(); // 儲存選中梁的唯一 key (格式: "story|name|joint1|joint2")
      var svgElement = null;

      // [新增] 對稱偵測參數 (可由 UI 調整，這裡設定預設值供後續覆寫)
      // [已模組化] Mirror 相關變數 (SYMMETRY_*, axis*) 已由 js/config/constants.js 和 js/features/mirror-mode.js 管理
      // constants.js 中的 mirrorState 會自動與 window 上的這些變數同步 (如果存在)
      // 但現在我們移除本地 let 定義，讓所有存取直接走 window 或 mirrorState


      // [新增] 標準層群組快取
      // [新增] 標準層群組快取
      var standardFloorGroupsCache = null;

      // [新增] 滾輪中鍵拖動畫布的狀態變數（類似 AutoCAD）
      var isMiddleMousePanning = false;
      var middleMouseStartPos = null;

      // [修復] Mirror 相關變數 - 必須在 index.html 中定義供 processE2k 等函數使用

      // 這些變數會透過 mirrorState (constants.js) 的 getter/setter 與模組同步
      // [修復] Mirror 相關變數 - 必須在 index.html 中定義供 processE2k 等函數使用
      // 這些變數會透過 mirrorState (constants.js) 的 getter/setter 與模組同步
      var userSymmetryAxisValue = null;
      var detectedSymmetryAxis = null;
      var symmetryAxisDirection = "vertical";
      var showSymmetryAxisLine = true;

      // [修復] Mirror 功能所需的容差常數 - 使用 var 確保全域作用域
      // 如果 mirrorState 已載入則使用其值，否則使用預設值
      var SYMMETRY_PASS_SCORE = (typeof window.mirrorState !== 'undefined' && window.mirrorState.SYMMETRY_PASS_SCORE) || 0.7;
      var SYMMETRY_TOLERANCE = (typeof window.mirrorState !== 'undefined' && window.mirrorState.SYMMETRY_TOLERANCE) || 0.5;
      var MATCHING_TOLERANCE = (typeof window.mirrorState !== 'undefined' && window.mirrorState.MATCHING_TOLERANCE) || 0.8;

      // [新增] 字體大小控制
      var currentFontSize = 14; // 預設字體大小（像素） - changed to var to expose to window

      // [新增] 顯示內嵌狀態訊息（在控制列內動態顯示，使用原本的樣式）
      function showInlineStatus(message, type = "success") {
        const statusInline = document.getElementById("status-inline");
        if (!statusInline) return;

        // 使用原本的 <p> 樣式，與舊的 status div 相同
        statusInline.innerHTML = `<p>${message}</p>`;
        statusInline.style.display = "block";
      }

      // [新增] 隱藏內嵌狀態訊息
      function hideInlineStatus() {
        const statusInline = document.getElementById("status-inline");
        if (statusInline) {
          statusInline.style.display = "none";
          statusInline.innerHTML = "";
        }
      }

      function updateFontSize() {
        const fontSizeInput = document.getElementById("fontSizeInput");
        currentFontSize = parseInt(fontSizeInput.value) || 14;

        console.log("字體大小已更新為:", currentFontSize);

        // 重新繪製圖表以應用新的字體大小和動態偏移距離
        // 這會確保標籤位置隨字體大小自動調整
        if (typeof handleStoryChange === "function") {
          handleStoryChange();
        }
      }

      // 為字體大小輸入框添加滑鼠滾輪支援
      document.addEventListener("DOMContentLoaded", function () {
        const fontSizeInput = document.getElementById("fontSizeInput");

        if (fontSizeInput) {
          fontSizeInput.addEventListener("wheel", function (e) {
            e.preventDefault();

            const delta = e.deltaY > 0 ? -1 : 1;
            let newValue = parseInt(this.value) + delta;

            // 限制範圍
            newValue = Math.max(1, Math.min(72, newValue));

            this.value = newValue;
            updateFontSize();
          });
        }

        // 為對稱評分設定輸入框添加滑鼠滾輪支援
        // [恢復] 原始函數仍在使用，暫時保留
        initSymmetrySettingsWheelSupport();

        // 載入儲存的對稱評分設定
        // [恢復] 原始函數仍在使用，暫時保留
        loadSymmetrySettings();
      });

      // [已模組化] initSymmetrySettingsWheelSupport, updateSymmetrySettings 等函數已移至 js/features/mirror-mode.js
      // 由 main.js 掛載到 window


      // ============ [新增] 對稱軸設定相關函數 ============

      // [已模組化] toggleSymmetryAxisLine ~ onAxisInputMethodChange 已移至 js/features/mirror-mode.js


      // [已模組化] 點選模式相關函數已移至 js/features/mirror-mode.js


      // [新增] 儲存的座標轉換參數（供反向轉換使用）
      let savedTransformParams = null;

      // [已模組化] svgToEtabsCoord, updateAxisDisplay, populateSymmetryAxisGridDropdown 等已移至 js/features/mirror-mode.js


      // [已模組化] detectSymmetryAxisWithDirection 已移至 js/features/mirror-mode.js


      // [已模組化] drawSymmetryAxisLine, Modal 相關函數已移至 js/features/mirror-mode.js


      // [新增] 格線編號說明提示
      function toggleGridConfigHelp() {
        // 檢查是否已有提示框
        const existingHelp = document.getElementById("grid-config-help-popup");
        const existingOverlay = document.getElementById(
          "grid-config-help-overlay"
        );
        if (existingHelp) {
          existingHelp.remove();
          if (existingOverlay) existingOverlay.remove();
          return;
        }

        // 創建提示框
        const helpPopup = document.createElement("div");
        helpPopup.id = "grid-config-help-popup";
        helpPopup.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          z-index: 10003;
          background: var(--theme-surface);
          border: 1px solid var(--theme-border);
          border-radius: 12px;
          padding: 20px;
          box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
          max-width: 450px;
        `;
        helpPopup.innerHTML = `
          <h3 style="margin-top: 0; display: flex; align-items: center; gap: 8px;">
            <span style="font-size: 1.2em;">💡</span> 格線編號說明
          </h3>
          <div style="color: var(--theme-text-secondary); font-size: 0.95em; line-height: 1.6;">
            <p style="margin-bottom: 10px;">
              • 輸入<b>數字</b>後，系統會自動幫後面的格線<b>順號</b><br>
              <span style="color: var(--theme-text-secondary); font-size: 0.9em; margin-left: 12px;">
                例如：設定 A=1，系統自動設定 B=2, C=3...
              </span>
            </p>
            <p style="margin-bottom: 10px;">
              • 輸入 <code style="background: var(--theme-bg); padding: 2px 6px; border-radius: 3px;">-</code> /
              <code style="background: var(--theme-bg); padding: 2px 6px; border-radius: 3px;">skip</code> / 留空<br>
              <span style="color: var(--theme-text-secondary); font-size: 0.9em; margin-left: 12px;">
                來跳過不編號的格線
              </span>
            </p>
            <p style="margin-bottom: 0;">
              • 您隨時可以手動修改任何格線的編號
            </p>
          </div>
          <div style="text-align: right; margin-top: 15px;">
            <button onclick="document.getElementById('grid-config-help-popup').remove(); document.getElementById('grid-config-help-overlay').remove();"
                    class="btn-export" style="padding: 8px 20px;">
              知道了
            </button>
          </div>
        `;

        // 創建遮罩
        const overlay = document.createElement("div");
        overlay.id = "grid-config-help-overlay";
        overlay.className = "dialog-overlay";
        overlay.style.display = "block";
        overlay.onclick = function () {
          helpPopup.remove();
          overlay.remove();
        };

        document.body.appendChild(overlay);
        document.body.appendChild(helpPopup);
      }

      // [新增] 固定編號功能函數
      // [已模組化] Fixed Label 功能 (toggleFixedLabelConfig, addFixedLabelRuleModal 等) 已移至 js/features/fixed-label.js


      // [新增] 預覽檔案函式
      async function previewFile() {
        console.log("[DEBUG] previewFile() called");

        try {
          const fileInput = document.getElementById("e2kFile");
          const statusDiv = document.getElementById("status");
          const storySelector = document.getElementById("storySelector");
          const beamTypeSelector = document.getElementById("beamTypeSelector");
          const drawingSvg = document.getElementById("drawing-svg");
          const gridConfigPanel = document.getElementById("grid-config-panel");

          // 檢查必要的 DOM 元素是否存在
          if (!fileInput || !statusDiv || !storySelector || !drawingSvg) {
            console.error("[ERROR] Required DOM elements not found");
            if (statusDiv) {
              statusDiv.innerHTML =
                '<p class="error">頁面初始化錯誤，請重新載入頁面</p>';
            }
            return;
          }

          statusDiv.innerHTML = "";

          // [修正] 在清空 SVG 之前先銷毀 panZoomInstance，避免 removeChild 錯誤
          if (panZoomInstance) {
            try {
              panZoomInstance.destroy();
            } catch (e) {
              console.warn("[WARN] Failed to destroy panZoomInstance:", e);
            }
            panZoomInstance = null;
          }

          drawingSvg.innerHTML = "";
          if (gridConfigPanel) {
            gridConfigPanel.style.display = "none";
          }

          // [修正] 清空編號資料，確保切換檔案時進入預覽模式
          fullProcessedBeams = [];

          if (fileInput.files.length === 0) {
            statusDiv.innerHTML = '<p class="error">請先選擇 .e2k 檔案</p>';
            return;
          }

          const file = fileInput.files[0];
          statusDiv.innerHTML = `<p>正在讀取檔案 "${file.name}"...</p>`;
          console.log(`[DEBUG] Reading file: ${file.name}`);

          previewFileContent = await file.text();

          // 解析樓層
          const storySectionMatch = previewFileContent.match(
            /\$ STORIES - IN SEQUENCE FROM TOP([\s\S]*?)(?=\$|$)/i
          );
          if (!storySectionMatch) throw new Error("找不到樓層定義");

          const allStoryNames = storySectionMatch[1]
            .trim()
            .split("\n")
            .map((line) => line.match(/STORY\s+"([^"]+)"/i)?.[1])
            .filter(Boolean);
          if (allStoryNames.length === 0) throw new Error("樓層定義為空");

          availableStories = allStoryNames;
          populateStorySelector();

          // 解析格線和節點
          gridData = parseGrids(previewFileContent);
          window.gridData = gridData; // [修復] 同步到 window，供模組 (如 handleAutoIncrement) 使用
          previewJoints = parseJoints(previewFileContent);

          // [新增] 載入已儲存的格線配置
          try {
            const saved = localStorage.getItem("userGridConfig");
            if (saved) {
              userGridConfig = JSON.parse(saved);
              console.log("✓ 已載入格線編號規則");
            }
          } catch (e) {
            console.error("載入格線編號規則失敗:", e);
          }

          // 解析所有梁並顯示
          let allBeamsAcrossStories = [];
          for (const story of availableStories) {
            const frames = parseFrames(previewFileContent, story);
            if (frames.length > 0) allBeamsAcrossStories.push(...frames);
          }

          fullDrawableBeams = allBeamsAcrossStories.map((f) => ({
            ...f,
            j1: previewJoints[f.joint1],
            j2: previewJoints[f.joint2],
          }));

          storyOrderInfo = availableStories.reduce((acc, story, index) => {
            acc[story] = index;
            return acc;
          }, {});

          // 顯示預覽圖
          if (availableStories.includes("2F")) {
            storySelector.value = "2F";
          }
          handleStoryChange();

          // [修改] 顯示狀態訊息到控制列的內嵌區域
          showInlineStatus(
            `✅ 預覽完成！找到 ${availableStories.length} 個樓層，${allBeamsAcrossStories.length} 根梁`,
            "success"
          );
          console.log(
            `[DEBUG] Preview completed: ${availableStories.length} floors, ${allBeamsAcrossStories.length} beams`
          );

          // 啟用「設定編號規則並執行」按鈕
          const configBtn = document.getElementById("configBtn");
          if (configBtn) {
            configBtn.disabled = false;
          }
        } catch (error) {
          console.error("[ERROR] Preview failed:", error);
          const statusDiv = document.getElementById("status");
          if (statusDiv) {
            statusDiv.innerHTML = `<p class="error">預覽失敗: ${error.message}</p><p class="error">請查看瀏覽器控制台以獲取詳細錯誤信息</p>`;
          }
          // 重新拋出錯誤以便在控制台看到完整堆疊
          throw error;
        }
      }

      // [新增] 顯示格線配置介面
      function showGridConfig() {
        if (!gridData || (!gridData.x.length && !gridData.y.length)) {
          alert("請先預覽檔案");
          return;
        }

        const panel = document.getElementById("grid-config-panel");
        const xConfigDiv = document.getElementById("x-grid-config");
        const yConfigDiv = document.getElementById("y-grid-config");

        // [新增] 獲取已儲存的格線配置值
        const getSavedValue = (axis, gridName, defaultIndex) => {
          if (userGridConfig && userGridConfig[axis]) {
            const savedConfig = userGridConfig[axis].find(
              (c) => c.name === gridName
            );
            if (savedConfig) {
              if (savedConfig.serialValue === null) {
                return "-"; // 跳過的格線
              }
              return savedConfig.serialValue;
            }
          }
          return defaultIndex + 1; // 預設值
        };

        // [新增] Grid Line 系統顏色配置（與結構平面圖的 Grid Bubble 一致）
        const COORDSYSTEM_COLORS = {
          GLOBAL: "#4A90E2", // 藍色 - GLOBAL 系統
          O2: "#E24A4A", // 紅色
          A2: "#50C878", // 綠色
          A3: "#F39C12", // 橙色
          DEFAULT: "#9B59B6", // 紫色 - 其他系統
        };

        const getCoordSystemColor = (coordsystem) => {
          return (
            COORDSYSTEM_COLORS[coordsystem] || COORDSYSTEM_COLORS["DEFAULT"]
          );
        };

        // [修正] 計算 X 和 Y 軸所有 Grid 名稱中最長的，統一所有圓的大小
        let globalMaxLen = 0;
        [...gridData.x, ...gridData.y].forEach((g) => {
          if (g.name.length > globalMaxLen) globalMaxLen = g.name.length;
        });
        // 統一圓的直徑（基於最長名稱，最小 60px，確保所有系統一致）
        const globalCircleSize = Math.max(60, 40 + globalMaxLen * 10);

        // 輔助函數：按 COORDSYSTEM 分組生成格線配置 HTML (圓形分割設計)
        const generateGridConfigHTML = (grids, axis) => {
          let html = "";
          let currentCoordSystem = null;
          let globalIndex = 0;
          let cardsInGroup = [];
          let groupStartIndex = 0;

          // 使用全域統一的圓大小
          const circleSize = globalCircleSize;

          const flushCards = () => {
            if (cardsInGroup.length > 0) {
              // [修正] 使用 CSS Grid 固定每排 5 顆圓，置中對齊
              html += `<div style="display: grid; grid-template-columns: repeat(5, ${circleSize}px); gap: 12px; margin-bottom: 15px; justify-content: center;">${cardsInGroup.join(
                ""
              )}</div>`;
              cardsInGroup = [];
            }
          };

          grids.forEach((grid) => {
            const coordsystem = grid.coordsystem || "GLOBAL";

            // 如果是新的 COORDSYSTEM，先輸出之前的卡片，再添加分組標題
            if (coordsystem !== currentCoordSystem) {
              flushCards();
              currentCoordSystem = coordsystem;
              groupStartIndex = globalIndex;
              html += `
                <div style="margin-top: ${
                  globalIndex > 0 ? "15px" : "0"
                }; margin-bottom: 8px; padding: 6px 10px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; font-weight: 600; font-size: 0.85em; border-radius: 4px; display: inline-block;">
                  📐 ${coordsystem}
                </div>
              `;
            }

            const savedValue = getSavedValue(axis, grid.name, globalIndex);
            const bgColor = getCoordSystemColor(coordsystem);
            // 根據圓的大小動態調整字體大小
            const fontSize =
              circleSize <= 60
                ? "0.85em"
                : circleSize <= 70
                ? "0.8em"
                : "0.75em";
            const inputFontSize = circleSize <= 60 ? "0.9em" : "0.85em";

            // 圓形分割設計：上半圓顯示 Grid 名稱，下半圓顯示可編輯流水號
            cardsInGroup.push(`
              <div style="
                width: ${circleSize}px;
                height: ${circleSize}px;
                border-radius: 50%;
                overflow: hidden;
                box-shadow: 0 2px 6px rgba(0,0,0,0.15);
                display: flex;
                flex-direction: column;
                border: 2px solid ${bgColor};
              ">
                <!-- 上半圓：Grid 名稱 -->
                <div style="
                  height: 50%;
                  background: ${bgColor};
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  color: white;
                  font-weight: 600;
                  font-size: ${fontSize};
                  white-space: nowrap;
                  padding: 0 4px;
                  box-sizing: border-box;
                ">${grid.name}</div>
                <!-- 下半圓：可編輯流水號 -->
                <div style="
                  height: 50%;
                  background: white;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  padding: 0 2px;
                  box-sizing: border-box;
                ">
                  <input type="text"
                    id="${axis}-grid-${globalIndex}"
                    value="${savedValue}"
                    style="
                      width: 100%;
                      height: 100%;
                      border: none;
                      background: transparent;
                      text-align: center;
                      font-size: ${inputFontSize};
                      font-weight: 500;
                      color: var(--theme-text-primary);
                      outline: none;
                      padding: 0;
                    "
                    placeholder="-"
                    title="輸入數字、名稱，或使用 - / skip / 空白 來跳過此格線"
                    data-axis="${axis}"
                    data-index="${globalIndex}"
                  />
                </div>
              </div>
            `);
            globalIndex++;
          });

          // 輸出最後一組的卡片
          flushCards();

          return html;
        };

        // 生成 X 軸格線配置（按 COORDSYSTEM 分組）
        xConfigDiv.innerHTML = generateGridConfigHTML(gridData.x, "x");

        // 生成 Y 軸格線配置（按 COORDSYSTEM 分組）
        yConfigDiv.innerHTML = generateGridConfigHTML(gridData.y, "y");

        // [新增] 為所有輸入框添加自動順號事件
        // 使用模組化函數（由 main.js 掛載到 window）
        if (typeof window.attachAutoIncrementListeners === 'function') {
          window.attachAutoIncrementListeners();
        } else {
          console.warn('[showGridConfig] attachAutoIncrementListeners not loaded yet');
        }

        panel.style.display = "block";
      }

      // [已模組化] AutoIncrement 相關函數 (attachAutoIncrementListeners, handleAutoIncrement) 已移至 js/features/batch-edit.js
      // 由 main.js 掛載到 window


      // [新增] 套用使用者配置
      function applyGridConfig() {
        // 收集使用者輸入
        userGridConfig = {
          x: gridData.x.map((grid, index) => {
            const inputValue = document
              .getElementById(`x-grid-${index}`)
              .value.trim();
            // [修改] 支援空值、"-" 或 "skip" 來跳過該格線
            if (
              inputValue === "" ||
              inputValue === "-" ||
              inputValue.toLowerCase() === "skip"
            ) {
              return {
                name: grid.name,
                serialValue: null, // null 表示跳過，不會被用於編號
                lineType: grid.lineType,
              };
            }
            return {
              name: grid.name,
              serialValue: isNaN(inputValue)
                ? inputValue
                : parseInt(inputValue, 10),
              lineType: grid.lineType,
            };
          }),
          y: gridData.y.map((grid, index) => {
            const inputValue = document
              .getElementById(`y-grid-${index}`)
              .value.trim();
            // [修改] 支援空值、"-" 或 "skip" 來跳過該格線
            if (
              inputValue === "" ||
              inputValue === "-" ||
              inputValue.toLowerCase() === "skip"
            ) {
              return {
                name: grid.name,
                serialValue: null, // null 表示跳過，不會被用於編號
                lineType: grid.lineType,
              };
            }
            return {
              name: grid.name,
              serialValue: isNaN(inputValue)
                ? inputValue
                : parseInt(inputValue, 10),
              lineType: grid.lineType,
            };
          }),
        };

        // [新增] 儲存格線配置到 localStorage
        try {
          localStorage.setItem(
            "userGridConfig",
            JSON.stringify(userGridConfig)
          );
          console.log("✓ 已儲存格線編號規則");
        } catch (e) {
          console.error("儲存格線編號規則失敗:", e);
        }

        document.getElementById("grid-config-panel").style.display = "none";

        // 自動執行編號
        processE2k();
      }

      // [新增] 取消配置
      function cancelGridConfig() {
        document.getElementById("grid-config-panel").style.display = "none";
      }

      // [新增] Grid Bubble 顯示控制相關函數
      let gridSystemVisibility = {}; // 儲存各 COORDSYSTEM 的顯示狀態
      let currentGridData = null; // 儲存當前的 grid 資料供拖曳使用

      // 切換說明對話框的顯示
      function toggleHelpDialog() {
        const helpBox = document.getElementById("help-info-box");
        if (helpBox.style.display === "none") {
          helpBox.style.display = "block";
        } else {
          helpBox.style.display = "none";
        }
      }

      // 開啟 Grid Bubble 控制 Modal
      function toggleGridBubbleControlPanel() {
        openGridBubbleModal();
      }

      function openGridBubbleModal() {
        const panel = document.getElementById("grid-bubble-control-panel");
        const overlay = document.getElementById("grid-bubble-overlay");
        // 初始化控制面板（如果還沒有初始化）
        initializeGridBubbleControls();
        panel.style.display = "block";
        overlay.style.display = "block";
        // 防止背景滾動
        document.body.style.overflow = "hidden";
      }

      function closeGridBubbleModal() {
        const panel = document.getElementById("grid-bubble-control-panel");
        const overlay = document.getElementById("grid-bubble-overlay");
        panel.style.display = "none";
        overlay.style.display = "none";
        // 恢復背景滾動
        document.body.style.overflow = "";
      }

      // 初始化 Grid Bubble 控制開關
      function initializeGridBubbleControls() {
        if (!gridData || !gridData.coordSystems) {
          console.log("No grid data available");
          return;
        }

        const togglesContainer = document.getElementById("grid-system-toggles");
        togglesContainer.innerHTML = ""; // 清空現有內容

        // 獲取所有 COORDSYSTEM
        const coordSystems = Object.keys(gridData.coordSystems);

        if (coordSystems.length === 0) {
          togglesContainer.innerHTML =
            '<p style="color: var(--theme-text-secondary);">沒有可用的 Grid Line 系統</p>';
          return;
        }

        // 顏色配置（與繪圖時使用的相同）
        const COORDSYSTEM_COLORS = {
          GLOBAL: "#4A90E2",
          O2: "#E24A4A",
          A2: "#50C878",
          A3: "#F39C12",
          DEFAULT: "#9B59B6",
        };

        // 為每個 COORDSYSTEM 創建開關
        coordSystems.forEach((systemName) => {
          // 初始化為顯示狀態
          if (gridSystemVisibility[systemName] === undefined) {
            gridSystemVisibility[systemName] = true;
          }

          const color =
            COORDSYSTEM_COLORS[systemName] || COORDSYSTEM_COLORS["DEFAULT"];
          const isVisible = gridSystemVisibility[systemName];

          const toggleDiv = document.createElement("div");
          toggleDiv.className = "grid-system-toggle";
          toggleDiv.innerHTML = `
            <label for="toggle-${systemName}">
              <span class="grid-system-color-indicator" style="background-color: ${color};"></span>
              <span>${systemName}</span>
            </label>
            <div class="toggle-switch ${
              isVisible ? "active" : ""
            }" onclick="toggleGridSystem('${systemName}')">
              <input type="checkbox" id="toggle-${systemName}" ${
            isVisible ? "checked" : ""
          }>
              <div class="toggle-switch-slider"></div>
            </div>
          `;
          togglesContainer.appendChild(toggleDiv);
        });

        // [新增] 對稱軸線開關
        const symmetryToggleDiv = document.createElement("div");
        symmetryToggleDiv.className = "grid-system-toggle";
        symmetryToggleDiv.innerHTML = `
          <label for="toggle-symmetry-axis">
            <span class="grid-system-color-indicator" style="background-color: #5D4037;"></span>
            <span>對稱軸</span>
          </label>
          <div class="toggle-switch ${
            showSymmetryAxisLine ? "active" : ""
          }" onclick="toggleSymmetryAxisLine()">
            <input type="checkbox" id="toggle-symmetry-axis" ${
              showSymmetryAxisLine ? "checked" : ""
            }>
            <div class="toggle-switch-slider"></div>
          </div>
        `;
        togglesContainer.appendChild(symmetryToggleDiv);
      }

      // 切換特定 Grid System 的顯示狀態
      function toggleGridSystem(systemName) {
        // 切換狀態
        gridSystemVisibility[systemName] = !gridSystemVisibility[systemName];
        const isVisible = gridSystemVisibility[systemName];

        // 更新 UI 開關狀態
        const checkbox = document.getElementById(`toggle-${systemName}`);
        const toggleSwitch = checkbox.parentElement;
        checkbox.checked = isVisible;
        if (isVisible) {
          toggleSwitch.classList.add("active");
        } else {
          toggleSwitch.classList.remove("active");
        }

        // 更新 SVG 中的元素顯示狀態
        const svg = document.getElementById("drawing-svg");
        if (!svg) return;

        // 找出所有該 COORDSYSTEM 的 bubble, text, connector, grid line
        const bubbles = svg.querySelectorAll(
          `.grid-bubble[data-coordsystem="${systemName}"]`
        );
        const texts = svg.querySelectorAll(
          `.grid-bubble-text[data-coordsystem="${systemName}"]`
        );
        const connectors = svg.querySelectorAll(
          `.grid-bubble-connector[data-coordsystem="${systemName}"]`
        );
        const gridLines = svg.querySelectorAll(
          `.grid-line-element[data-coordsystem="${systemName}"]`
        );

        // 切換 hidden class
        [bubbles, texts, connectors, gridLines].forEach((elements) => {
          elements.forEach((el) => {
            if (isVisible) {
              el.classList.remove("hidden");
            } else {
              el.classList.add("hidden");
            }
          });
        });

        console.log(`${systemName} system ${isVisible ? "shown" : "hidden"}`);
      }

      // [新增] 套用已儲存的 Grid System 顯示狀態（重繪後呼叫）
      function applyGridSystemVisibility() {
        const svg = document.getElementById("drawing-svg");
        if (!svg) return;

        Object.keys(gridSystemVisibility).forEach((systemName) => {
          const isVisible = gridSystemVisibility[systemName];
          if (isVisible) return; // 預設是顯示的，只需處理隱藏的

          // 隱藏該系統的所有元素
          const bubbles = svg.querySelectorAll(
            `.grid-bubble[data-coordsystem="${systemName}"]`
          );
          const texts = svg.querySelectorAll(
            `.grid-bubble-text[data-coordsystem="${systemName}"]`
          );
          const connectors = svg.querySelectorAll(
            `.grid-bubble-connector[data-coordsystem="${systemName}"]`
          );
          const gridLines = svg.querySelectorAll(
            `.grid-line-element[data-coordsystem="${systemName}"]`
          );

          [bubbles, texts, connectors, gridLines].forEach((elements) => {
            elements.forEach((el) => el.classList.add("hidden"));
          });
        });
      }

      // [新增] Grid Bubble 拖曳功能
      let dragState = {
        isDragging: false,
        currentBubble: null,
        currentText: null,
        currentConnector: null,
        originalBubblePos: null, // 記錄原始位置
        gridLineEnd: null,
        gridLineDirection: null, // [新增] grid line 方向向量
        startMousePos: null,
        maxDragDistance: null, // [新增] 最大拖曳距離 (±5 bubble)
      };

      // 初始化拖曳事件監聽器（在繪製完成後呼叫）
      function initializeBubbleDragging() {
        const svg = document.getElementById("drawing-svg");
        if (!svg) return;

        // [修改] 先移除舊的全域事件監聽器，避免重複綁定
        // 綁定到 document 而不是 svg，確保即使鼠標移出 SVG 範圍也能繼續拖曳
        document.removeEventListener("mousemove", handleBubbleMouseMove);
        document.removeEventListener("mouseup", handleBubbleMouseUp);

        // [修改] 移除個別 hitarea 的事件監聽器，改用 SVG 統一處理
        // 這樣可以在 mousedown 時找到最接近鼠標的 bubble，避免重疊 bubble 誤判
        svg.removeEventListener("mousedown", handleBubbleMouseDown);
        svg.addEventListener("mousedown", handleBubbleMouseDown);

        // 全域 mousemove 和 mouseup 事件綁定到 document
        document.addEventListener("mousemove", handleBubbleMouseMove);
        document.addEventListener("mouseup", handleBubbleMouseUp);

        const hitareas = svg.querySelectorAll(".grid-bubble-hitarea.draggable");
        console.log(
          "[DEBUG] Bubble dragging initialized successfully, hitareas:",
          hitareas.length
        );
      }

      function handleBubbleMouseDown(e) {
        const svg = document.getElementById("drawing-svg");
        if (!svg) return;

        // [修改] 先獲取鼠標在 SVG 座標系中的位置
        const pt = getSVGPoint(svg, e);
        if (!pt) {
          // SVG 尚未完全渲染，讓事件正常傳播
          return;
        }
        const mouseX = pt.x;
        const mouseY = pt.y;

        // [修改] 找到所有 hitareas，並計算與鼠標的距離，選擇最近的那個
        const hitareas = svg.querySelectorAll(".grid-bubble-hitarea.draggable");
        let closestHitarea = null;
        let minDistance = Infinity;

        // [修改] 設定合理的最大點擊距離（SVG 座標單位）
        // 使用 hitarea 的實際半徑（INITIAL_GRID_BUBBLE_RADIUS + 5 = 23）
        // 這樣只有在點擊位置確實在 bubble 範圍內才會觸發拖動
        const MAX_CLICK_DISTANCE = INITIAL_GRID_BUBBLE_RADIUS + 5;

        hitareas.forEach((ha) => {
          const cx = parseFloat(ha.getAttribute("cx"));
          const cy = parseFloat(ha.getAttribute("cy"));
          const dist = Math.sqrt((mouseX - cx) ** 2 + (mouseY - cy) ** 2);

          // [修改] 只要距離是最近的，就選擇它（不再限制必須在 r 範圍內）
          if (dist < minDistance) {
            closestHitarea = ha;
            minDistance = dist;
          }
        });

        // [修改] 如果最近的 bubble 距離太遠（超過閾值），說明沒有點擊在 bubble 上
        if (!closestHitarea || minDistance > MAX_CLICK_DISTANCE) {
          return; // 讓其他事件（如圈選）處理
        }

        // 防止與圈選功能衝突
        e.stopPropagation();
        e.preventDefault();

        const hitarea = closestHitarea;
        const coordsystem = hitarea.getAttribute("data-coordsystem");

        // 找到對應的 bubble、text 和 connector
        const hitareaCx = parseFloat(hitarea.getAttribute("cx"));
        const hitareaCy = parseFloat(hitarea.getAttribute("cy"));

        console.log("[DEBUG] Closest hitarea selected:", {
          coordsystem,
          mousePos: { x: mouseX, y: mouseY },
          hitareaPos: { cx: hitareaCx, cy: hitareaCy },
          distance: minDistance,
          maxAllowed: MAX_CLICK_DISTANCE,
        });

        const bubbles = svg.querySelectorAll(
          `.grid-bubble[data-coordsystem="${coordsystem}"]`
        ); // [新增] 查找真正的 bubble
        const texts = svg.querySelectorAll(
          `.grid-bubble-text[data-coordsystem="${coordsystem}"]`
        );
        const connectors = svg.querySelectorAll(
          `.grid-bubble-connector[data-coordsystem="${coordsystem}"]`
        );

        console.log("[DEBUG] Hitarea mousedown:", {
          coordsystem,
          hitareaCx,
          hitareaCy,
          bubblesCount: bubbles.length,
          textsCount: texts.length,
          connectorsCount: connectors.length,
        });

        // [新增] 找到位置相同的真正 bubble 圓圈
        let matchingBubble = null;
        let minBubbleDist = Infinity;
        bubbles.forEach((bubble) => {
          const bx = parseFloat(bubble.getAttribute("cx"));
          const by = parseFloat(bubble.getAttribute("cy"));
          const dist = Math.sqrt((bx - hitareaCx) ** 2 + (by - hitareaCy) ** 2);
          if (dist < 10 && dist < minBubbleDist) {
            matchingBubble = bubble;
            minBubbleDist = dist;
          }
        });

        // 找到位置相同的 text（放寬匹配條件到 10 像素）
        let matchingText = null;
        let minTextDist = Infinity;
        texts.forEach((text) => {
          const tx = parseFloat(text.getAttribute("x"));
          const ty = parseFloat(text.getAttribute("y"));
          const dist = Math.sqrt((tx - hitareaCx) ** 2 + (ty - hitareaCy) ** 2);
          if (dist < 10 && dist < minTextDist) {
            matchingText = text;
            minTextDist = dist;
          }
        });

        // 找到連接到這個 bubble 的 connector（放寬匹配條件到 10 像素）
        let matchingConnector = null;
        let minConnDist = Infinity;
        connectors.forEach((conn) => {
          const x1 = parseFloat(conn.getAttribute("x1"));
          const y1 = parseFloat(conn.getAttribute("y1"));
          const dist = Math.sqrt((x1 - hitareaCx) ** 2 + (y1 - hitareaCy) ** 2);
          console.log("[DEBUG] Checking connector:", { x1, y1, dist });
          if (dist < 10 && dist < minConnDist) {
            matchingConnector = conn;
            minConnDist = dist;
          }
        });

        // [新增] 檢查是否找到所有必要元素
        if (!matchingBubble) {
          console.warn(
            "[WARN] No matching bubble found at",
            hitareaCx,
            hitareaCy
          );
          return;
        }
        if (!matchingConnector) {
          console.warn(
            "[WARN] No matching connector found for bubble at",
            hitareaCx,
            hitareaCy
          );
          return;
        }

        console.log("[DEBUG] Found all elements:", {
          bubble: matchingBubble,
          text: matchingText,
          connector: {
            x1: matchingConnector.getAttribute("x1"),
            y1: matchingConnector.getAttribute("y1"),
            x2: matchingConnector.getAttribute("x2"),
            y2: matchingConnector.getAttribute("y2"),
          },
        });

        // 儲存拖曳狀態 - [修改] 使用真正的 bubble 元素
        dragState.isDragging = true;
        dragState.currentBubble = matchingBubble; // [修改] 保存真正的 bubble 而不是 hitarea
        dragState.currentText = matchingText;
        dragState.currentConnector = matchingConnector;

        // 記錄原始位置（用於回彈）- [修改] 使用 hitarea 的座標
        dragState.originalBubblePos = {
          x: hitareaCx,
          y: hitareaCy,
        };

        // 獲取 grid line 的固定端點（connector 的另一端）
        dragState.gridLineEnd = {
          x: parseFloat(matchingConnector.getAttribute("x2")),
          y: parseFloat(matchingConnector.getAttribute("y2")),
        };

        // [修正] BUBBLE 應該沿著 connector 的方向移動（垂直於 grid line）
        // 計算從 bubble 指向 grid line 的方向向量 - [修改] 使用 hitarea 座標
        const connectorDx = dragState.gridLineEnd.x - hitareaCx;
        const connectorDy = dragState.gridLineEnd.y - hitareaCy;
        const connectorLength = Math.sqrt(
          connectorDx * connectorDx + connectorDy * connectorDy
        );

        // connector 的單位向量
        let connectorUnitX = 0;
        let connectorUnitY = 0;

        if (connectorLength > 0.01) {
          connectorUnitX = connectorDx / connectorLength;
          connectorUnitY = connectorDy / connectorLength;

          // [修正] 直接使用 connector 的方向（不需要旋轉）
          // BUBBLE 沿著垂直於 grid line 的方向移動
          dragState.gridLineDirection = {
            x: connectorUnitX,
            y: connectorUnitY,
          };
        } else {
          dragState.gridLineDirection = { x: 0, y: 1 }; // 預設垂直方向
        }

        console.log(
          "[DEBUG] Grid line direction:",
          dragState.gridLineDirection,
          "Connector unit:",
          { x: connectorUnitX, y: connectorUnitY }
        );

        // [修正] 設定統一的最大拖曳距離，確保所有 BUBBLE 有相同的移動感受
        // 使用固定距離而非基於 bubble 半徑，避免不同 BUBBLE 有不同的速度感
        dragState.maxDragDistance = 100; // 固定 100 單位的拖曳範圍

        // 獲取 SVG 座標系中的滑鼠位置（使用之前已經獲取的 pt）
        // 注意：pt 已在函數開頭聲明（line 1894），這裡直接使用
        dragState.startMousePos = pt;

        // [新增] 禁用 svg-pan-zoom 的平移功能，避免拖動時整個畫布跟著移動
        // [新增] 禁用 svg-pan-zoom 的平移功能 - 不需要
        // if (panZoomInstance) {
        //   panZoomInstance.disablePan();
        // }

        // 添加樣式防止文字選取 - [修改] 使用真正的 bubble 元素
        matchingBubble.classList.add("dragging");
        matchingConnector.classList.add("rubber-band");
        document.body.classList.add("dragging-bubble");

        console.log(
          "[SUCCESS] Started dragging bubble",
          coordsystem,
          "maxDistance:",
          dragState.maxDragDistance,
          "isDragging:",
          dragState.isDragging
        );
      }

      // [優化] 用於 Bubble 拖拽的 requestAnimationFrame 節流
      let bubbleAnimationFrameId = null;
      let pendingBubbleEvent = null;

      function handleBubbleMouseMove(e) {
        if (!dragState.isDragging) {
          // console.log("[DEBUG] MouseMove but not dragging");
          return;
        }

        e.preventDefault();
        e.stopPropagation();

        // [優化] 使用 requestAnimationFrame 節流
        pendingBubbleEvent = e;
        if (!bubbleAnimationFrameId) {
          bubbleAnimationFrameId = requestAnimationFrame(updateBubblePosition);
        }
      }

      // [優化] 獨立的 Bubble 位置更新函數
      function updateBubblePosition() {
        bubbleAnimationFrameId = null;
        if (!dragState.isDragging || !pendingBubbleEvent) return;

        const e = pendingBubbleEvent;
        const svg = document.getElementById("drawing-svg");
        const pt = getSVGPoint(svg, e);
        if (!pt) {
          pendingBubbleEvent = null;
          return;
        }

        // [修正] 計算鼠標相對於初始點擊位置的移動量（而不是相對於 BUBBLE 原始位置）
        const mouseDx = pt.x - dragState.startMousePos.x;
        const mouseDy = pt.y - dragState.startMousePos.y;

        // 投影到 connector 方向（點積）
        const projectionLength =
          mouseDx * dragState.gridLineDirection.x +
          mouseDy * dragState.gridLineDirection.y;

        // 限制在 ±maxDragDistance 範圍內
        const clampedLength = Math.max(
          -dragState.maxDragDistance,
          Math.min(dragState.maxDragDistance, projectionLength)
        );

        // 計算新的 bubble 位置（從原始位置沿 connector 方向偏移）
        const newCx =
          dragState.originalBubblePos.x +
          clampedLength * dragState.gridLineDirection.x;
        const newCy =
          dragState.originalBubblePos.y +
          clampedLength * dragState.gridLineDirection.y;

        // console.log("[DEBUG] Moving bubble:", { mouseDx, mouseDy, projectionLength, clampedLength, newCx, newCy });

        // 更新 bubble 位置
        dragState.currentBubble.setAttribute("cx", newCx);
        dragState.currentBubble.setAttribute("cy", newCy);

        // 更新 text 位置
        if (dragState.currentText) {
          dragState.currentText.setAttribute("x", newCx);
          dragState.currentText.setAttribute("y", newCy);
        }

        // 更新 connector (橡膠拉伸效果 - 從 bubble 拉到 grid line 端點)
        dragState.currentConnector.setAttribute("x1", newCx);
        dragState.currentConnector.setAttribute("y1", newCy);

        pendingBubbleEvent = null;
      }

      function handleBubbleMouseUp(e) {
        if (!dragState.isDragging) return;

        console.log("[DEBUG] Mouse up - checking if bubble moved");

        // [修改] 使用簡諧運動（彈簧效果）回到原始位置
        if (dragState.currentBubble && dragState.originalBubblePos) {
          const bubble = dragState.currentBubble;
          const text = dragState.currentText;
          const connector = dragState.currentConnector;
          const targetX = dragState.originalBubblePos.x;
          const targetY = dragState.originalBubblePos.y;

          // 獲取當前位置
          let currentX = parseFloat(bubble.getAttribute("cx"));
          let currentY = parseFloat(bubble.getAttribute("cy"));

          // [新增] 檢查 bubble 是否真的移動了（避免點擊時的跳動）
          const movedDistance = Math.sqrt(
            (currentX - targetX) ** 2 + (currentY - targetY) ** 2
          );

          // 如果移動距離小於 1 像素，視為沒有移動，直接重置狀態不執行動畫
          if (movedDistance < 1) {
            console.log("[DEBUG] Bubble didn't move, skipping animation");
            // 直接移除樣式
            if (dragState.currentBubble) {
              dragState.currentBubble.classList.remove("dragging");
            }
            if (dragState.currentConnector) {
              dragState.currentConnector.classList.remove("rubber-band");
            }
            document.body.classList.remove("dragging-bubble");

            // [新增] 重新啟用 svg-pan-zoom 的平移功能
            // [新增] 重新啟用 svg-pan-zoom 的平移功能 - 不需要
            // if (panZoomInstance) {
            //   panZoomInstance.enablePan();
            // }

            // 重置拖曳狀態
            dragState.isDragging = false;
            dragState.currentBubble = null;
            dragState.currentText = null;
            dragState.currentConnector = null;
            dragState.originalBubblePos = null;
            dragState.gridLineEnd = null;
            dragState.gridLineDirection = null;
            dragState.maxDragDistance = null;
            dragState.startMousePos = null;
            return;
          }

          console.log("[DEBUG] Bubble moved, starting spring animation");

          // [優化] 簡諧運動參數 - 提高剛度和阻尼，讓回彈更快更一致
          let velocity = { x: 0, y: 0 };
          const stiffness = 0.25; // 彈簧剛度 (提高到 0.25，回彈更快)
          const damping = 0.75; // 阻尼係數 (提高到 0.75，減少震盪)
          const minDistance = 0.5; // 停止閾值 (提高到 0.5，更快停止)

          // 動畫循環
          const animate = () => {
            // 計算位移
            const dx = targetX - currentX;
            const dy = targetY - currentY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // 如果已經很接近目標，停止動畫
            if (
              distance < minDistance &&
              Math.abs(velocity.x) < 0.01 &&
              Math.abs(velocity.y) < 0.01
            ) {
              bubble.setAttribute("cx", targetX);
              bubble.setAttribute("cy", targetY);
              if (text) {
                text.setAttribute("x", targetX);
                text.setAttribute("y", targetY);
              }
              if (connector) {
                connector.setAttribute("x1", targetX);
                connector.setAttribute("y1", targetY);
              }
              return;
            }

            // 彈簧力 F = -k * x
            const forceX = dx * stiffness;
            const forceY = dy * stiffness;

            // 更新速度（加入阻尼）
            velocity.x = (velocity.x + forceX) * damping;
            velocity.y = (velocity.y + forceY) * damping;

            // 更新位置
            currentX += velocity.x;
            currentY += velocity.y;

            // 應用到元素
            bubble.setAttribute("cx", currentX);
            bubble.setAttribute("cy", currentY);
            if (text) {
              text.setAttribute("x", currentX);
              text.setAttribute("y", currentY);
            }
            if (connector) {
              connector.setAttribute("x1", currentX);
              connector.setAttribute("y1", currentY);
            }

            // 繼續動畫
            requestAnimationFrame(animate);
          };

          // 開始動畫
          animate();
        }

        // 移除樣式
        if (dragState.currentBubble) {
          dragState.currentBubble.classList.remove("dragging");
        }
        if (dragState.currentConnector) {
          dragState.currentConnector.classList.remove("rubber-band");
        }
        document.body.classList.remove("dragging-bubble");

        console.log("Stopped dragging bubble - spring animation started");

        // [新增] 重新啟用 svg-pan-zoom 的平移功能
        // [新增] 重新啟用 svg-pan-zoom 的平移功能 - 不需要
        // if (panZoomInstance) {
        //   panZoomInstance.enablePan();
        // }

        // 重置拖曳狀態
        dragState.isDragging = false;
        dragState.currentBubble = null;
        dragState.currentText = null;
        dragState.currentConnector = null;
        dragState.originalBubblePos = null;
        dragState.gridLineEnd = null;
        dragState.gridLineDirection = null;
        dragState.maxDragDistance = null;
        dragState.startMousePos = null;
      }

      // [已模組化] getSVGPoint 已移至 js/utils/coord-transform.js
      // 由 main.js 掛載到 window.getSVGPoint


      // ============ 梁標籤拖曳功能 ============
      // [新增] 梁標籤拖曳狀態
      let beamLabelDragState = {
        isDragging: false,
        currentLabel: null,
        beamName: null,
        orientation: null, // 'horizontal', 'vertical', 'angled'
        originalPos: null, // {x, y}
        customOffset: 0, // 自訂偏移量（沿著垂直於梁的方向）
        startMousePos: null,
        maxDragDistance: 100, // 最大拖曳距離
      };

      // [新增] 儲存所有梁標籤的自訂偏移量 {beamName: offset}
      let beamLabelOffsets = {};

      // 初始化梁標籤拖曳功能
      function initializeBeamLabelDragging() {
        const svg = document.getElementById("drawing-svg");
        if (!svg) return;

        // 移除舊的事件監聽器
        svg.removeEventListener("mousedown", handleBeamLabelMouseDown);
        document.removeEventListener("mousemove", handleBeamLabelMouseMove);
        document.removeEventListener("mouseup", handleBeamLabelMouseUp);

        // 添加新的事件監聽器
        svg.addEventListener("mousedown", handleBeamLabelMouseDown);
        document.addEventListener("mousemove", handleBeamLabelMouseMove);
        document.addEventListener("mouseup", handleBeamLabelMouseUp);

        console.log("[DEBUG] Beam label dragging initialized");
      }

      function handleBeamLabelMouseDown(e) {
        // 只處理左鍵點擊
        if (e.button !== 0) return;

        const target = e.target;

        // 檢查是否點擊了梁標籤
        if (!target.classList.contains("beam-label")) return;

        // 避免與圈選功能衝突 - 如果點擊時沒有按住 Ctrl/Shift，允許拖動
        if (!e.ctrlKey && !e.shiftKey) {
          e.stopPropagation(); // 阻止事件冒泡到圈選功能
        } else {
          return; // 如果按住修飾鍵，讓圈選功能處理
        }

        const svg = document.getElementById("drawing-svg");
        const pt = getSVGPoint(svg, e);
        if (!pt) return;

        // 獲取標籤資訊
        const beamName = target.dataset.beamName;
        const orientation = target.dataset.orientation;

        if (!beamName || !orientation) return;

        // 記錄拖曳狀態
        beamLabelDragState.isDragging = true;
        beamLabelDragState.currentLabel = target;
        beamLabelDragState.beamName = beamName;
        beamLabelDragState.orientation = orientation;
        beamLabelDragState.startMousePos = pt;

        // 記錄原始位置
        beamLabelDragState.originalPos = {
          x: parseFloat(target.getAttribute("x")),
          y: parseFloat(target.getAttribute("y")),
        };

        // 載入之前儲存的偏移量
        beamLabelDragState.customOffset = beamLabelOffsets[beamName] || 0;

        // [新增] 禁用 svg-pan-zoom 的平移功能，避免拖動時整個畫布跟著移動
        // [新增] 禁用 svg-pan-zoom 的平移功能 - 不需要
        // if (panZoomInstance) {
        //   panZoomInstance.disablePan();
        // }

        // 添加拖曳樣式
        target.style.cursor = "grabbing";
        target.style.opacity = "0.7";
        document.body.classList.add("dragging-bubble");

        console.log(
          "[DEBUG] Started dragging beam label:",
          beamName,
          orientation
        );
      }

      // [優化] 用於梁標籤拖拽的 requestAnimationFrame 節流
      let beamLabelAnimationFrameId = null;
      let pendingBeamLabelEvent = null;

      function handleBeamLabelMouseMove(e) {
        if (!beamLabelDragState.isDragging) return;

        e.preventDefault();
        e.stopPropagation();

        // [優化] 使用 requestAnimationFrame 節流
        pendingBeamLabelEvent = e;
        if (!beamLabelAnimationFrameId) {
          beamLabelAnimationFrameId = requestAnimationFrame(
            updateBeamLabelPosition
          );
        }
      }

      // [優化] 獨立的梁標籤位置更新函數
      function updateBeamLabelPosition() {
        beamLabelAnimationFrameId = null;
        if (!beamLabelDragState.isDragging || !pendingBeamLabelEvent) return;

        const e = pendingBeamLabelEvent;
        const svg = document.getElementById("drawing-svg");
        const pt = getSVGPoint(svg, e);
        if (!pt) {
          pendingBeamLabelEvent = null;
          return;
        }

        const label = beamLabelDragState.currentLabel;
        const orientation = beamLabelDragState.orientation;

        // 計算鼠標移動量
        const mouseDx = pt.x - beamLabelDragState.startMousePos.x;
        const mouseDy = pt.y - beamLabelDragState.startMousePos.y;

        let projectionLength = 0;

        // 根據梁的方向，計算沿著允許方向的投影
        let moveDirectionX = 0; // 移動方向的單位向量
        let moveDirectionY = 0;

        if (orientation === "horizontal") {
          // 水平梁：只允許上下移動
          projectionLength = mouseDy;
          moveDirectionX = 0;
          moveDirectionY = 1;
        } else if (orientation === "vertical") {
          // 垂直梁：只允許左右移動
          projectionLength = mouseDx;
          moveDirectionX = 1;
          moveDirectionY = 0;
        } else if (orientation === "angled") {
          // 斜向梁：允許沿著垂直於梁的方向移動
          // 從 transform 屬性中提取旋轉角度
          const transform = label.getAttribute("transform");
          if (transform && transform.includes("rotate")) {
            const rotateMatch = transform.match(/rotate\(([^,]+)/);
            if (rotateMatch) {
              const angleInDegrees = parseFloat(rotateMatch[1]);
              const angleInRadians = (angleInDegrees * Math.PI) / 180;

              // 梁的方向向量（沿著旋轉角度）
              const beamDirX = Math.cos(angleInRadians);
              const beamDirY = Math.sin(angleInRadians);

              // 垂直於梁的方向（順時針旋轉 90 度）
              moveDirectionX = -beamDirY;
              moveDirectionY = beamDirX;

              // 將鼠標移動投影到垂直於梁的方向
              projectionLength =
                mouseDx * moveDirectionX + mouseDy * moveDirectionY;
            } else {
              // 如果無法解析角度，回退到垂直移動
              projectionLength = mouseDy;
              moveDirectionX = 0;
              moveDirectionY = 1;
            }
          } else {
            // 如果沒有 transform 屬性，回退到垂直移動
            projectionLength = mouseDy;
            moveDirectionX = 0;
            moveDirectionY = 1;
          }
        }

        // 限制在最大拖曳範圍內
        const clampedLength = Math.max(
          -beamLabelDragState.maxDragDistance,
          Math.min(beamLabelDragState.maxDragDistance, projectionLength)
        );

        // 更新自訂偏移量
        beamLabelDragState.customOffset = clampedLength;

        // 計算新位置（沿著移動方向）
        let newX = beamLabelDragState.originalPos.x;
        let newY = beamLabelDragState.originalPos.y;

        if (orientation === "horizontal") {
          newY += clampedLength;
        } else if (orientation === "vertical") {
          newX += clampedLength;
        } else if (orientation === "angled") {
          // 沿著垂直於梁的方向移動
          newX += clampedLength * moveDirectionX;
          newY += clampedLength * moveDirectionY;
        }

        // 更新標籤位置
        label.setAttribute("x", newX);
        label.setAttribute("y", newY);

        // 如果是旋轉的標籤，也需要更新旋轉中心
        const transform = label.getAttribute("transform");
        if (transform && transform.includes("rotate")) {
          const rotateMatch = transform.match(
            /rotate\(([^,]+),\s*([^,]+),\s*([^)]+)\)/
          );
          if (rotateMatch) {
            const angle = rotateMatch[1];
            label.setAttribute(
              "transform",
              `rotate(${angle}, ${newX}, ${newY})`
            );
          }
        }

        pendingBeamLabelEvent = null;
      }

      function handleBeamLabelMouseUp(e) {
        if (!beamLabelDragState.isDragging) return;

        console.log("[DEBUG] Mouse up - checking if label moved");

        const label = beamLabelDragState.currentLabel;
        const beamName = beamLabelDragState.beamName;
        const orientation = beamLabelDragState.orientation;

        // 獲取當前位置
        let currentX = parseFloat(label.getAttribute("x"));
        let currentY = parseFloat(label.getAttribute("y"));

        // 計算目標位置（回到原始位置，不保留拖動偏移）
        const targetX = beamLabelDragState.originalPos.x;
        const targetY = beamLabelDragState.originalPos.y;

        // 檢查標籤是否真的移動了
        const movedDistance = Math.sqrt(
          (currentX - targetX) ** 2 + (currentY - targetY) ** 2
        );

        // 如果移動距離小於 1 像素，視為沒有移動（點擊）
        if (movedDistance < 1) {
          console.log(
            "[DEBUG] Label didn't move, treating as click - triggering selection"
          );

          // 直接移除樣式
          if (label) {
            label.style.cursor = "move";
            label.style.opacity = "1";
          }
          document.body.classList.remove("dragging-bubble");

          // [新增] 觸發選取功能 - 沒有移動代表是點擊
          const beamStory = label.dataset.beamStory;
          const beamJoint1 = label.dataset.beamJoint1;
          const beamJoint2 = label.dataset.beamJoint2;

          if (beamName && beamStory) {
            const beamKey = `${beamStory}|${beamName}|${beamJoint1}|${beamJoint2}`;

            // Shift+Click：取消選擇
            if (e.shiftKey) {
              if (selectedBeams.has(beamKey)) {
                selectedBeams.delete(beamKey);
                updateBeamVisualState(beamKey, false);
              }
            } else {
              // 普通點擊：累加選擇
              if (!selectedBeams.has(beamKey)) {
                selectedBeams.add(beamKey);
                updateBeamVisualState(beamKey, true);
              }
            }
          }

          // [新增] 重新啟用 svg-pan-zoom 的平移功能
          // [新增] 重新啟用 svg-pan-zoom 的平移功能 - 不需要
          // if (panZoomInstance) {
          //   panZoomInstance.enablePan();
          // }

          // 重置拖曳狀態
          beamLabelDragState.isDragging = false;
          beamLabelDragState.currentLabel = null;
          beamLabelDragState.beamName = null;
          beamLabelDragState.orientation = null;
          beamLabelDragState.originalPos = null;
          beamLabelDragState.customOffset = 0;
          beamLabelDragState.startMousePos = null;
          return;
        }

        console.log("[DEBUG] Label moved, starting spring animation");

        // 不儲存偏移量，讓標籤回到原始位置

        // 彈簧動畫參數
        let velocity = { x: 0, y: 0 };
        const stiffness = 0.25; // 彈簧剛度
        const damping = 0.75; // 阻尼係數
        const minDistance = 0.5; // 停止閾值

        // 動畫循環
        const animate = () => {
          // 計算位移
          const dx = targetX - currentX;
          const dy = targetY - currentY;
          const distance = Math.sqrt(dx * dx + dy * dy);

          // 如果已經很接近目標，停止動畫
          if (
            distance < minDistance &&
            Math.abs(velocity.x) < 0.01 &&
            Math.abs(velocity.y) < 0.01
          ) {
            label.setAttribute("x", targetX);
            label.setAttribute("y", targetY);

            // 更新旋轉中心（如果是旋轉的標籤）
            const transform = label.getAttribute("transform");
            if (transform && transform.includes("rotate")) {
              const rotateMatch = transform.match(
                /rotate\(([^,]+),\s*([^,]+),\s*([^)]+)\)/
              );
              if (rotateMatch) {
                const angle = rotateMatch[1];
                label.setAttribute(
                  "transform",
                  `rotate(${angle}, ${targetX}, ${targetY})`
                );
              }
            }
            return;
          }

          // 彈簧力 F = -k * x
          const forceX = dx * stiffness;
          const forceY = dy * stiffness;

          // 更新速度（加入阻尼）
          velocity.x = (velocity.x + forceX) * damping;
          velocity.y = (velocity.y + forceY) * damping;

          // 更新位置
          currentX += velocity.x;
          currentY += velocity.y;

          // 應用到元素
          label.setAttribute("x", currentX);
          label.setAttribute("y", currentY);

          // 更新旋轉中心（如果是旋轉的標籤）
          const transform = label.getAttribute("transform");
          if (transform && transform.includes("rotate")) {
            const rotateMatch = transform.match(
              /rotate\(([^,]+),\s*([^,]+),\s*([^)]+)\)/
            );
            if (rotateMatch) {
              const angle = rotateMatch[1];
              label.setAttribute(
                "transform",
                `rotate(${angle}, ${currentX}, ${currentY})`
              );
            }
          }

          // 繼續動畫
          requestAnimationFrame(animate);
        };

        // 開始動畫
        animate();

        // 移除拖曳樣式
        if (label) {
          label.style.cursor = "move";
          label.style.opacity = "1";
        }
        document.body.classList.remove("dragging-bubble");

        // [新增] 重新啟用 svg-pan-zoom 的平移功能
        // [新增] 重新啟用 svg-pan-zoom 的平移功能 - 不需要
        // if (panZoomInstance) {
        //   panZoomInstance.enablePan();
        // }

        console.log(
          "[DEBUG] Stopped dragging beam label:",
          beamName,
          "offset:",
          beamLabelDragState.customOffset
        );

        // 重置拖曳狀態
        beamLabelDragState.isDragging = false;
        beamLabelDragState.currentLabel = null;
        beamLabelDragState.beamName = null;
        beamLabelDragState.orientation = null;
        beamLabelDragState.originalPos = null;
        beamLabelDragState.customOffset = 0;
        beamLabelDragState.startMousePos = null;
      }

      // [新增] 初始化滾輪中鍵拖動畫布功能（類似 AutoCAD）
      function initializeMiddleMousePan() {
        const svg = document.getElementById("drawing-svg");
        if (!svg) return;

        // 移除舊的事件監聽器
        svg.removeEventListener("mousedown", handleMiddleMouseDown);
        document.removeEventListener("mousemove", handleMiddleMouseMove);
        document.removeEventListener("mouseup", handleMiddleMouseUp);

        // 添加事件監聽器
        svg.addEventListener("mousedown", handleMiddleMouseDown);
        document.addEventListener("mousemove", handleMiddleMouseMove);
        document.addEventListener("mouseup", handleMiddleMouseUp);

        // 防止中鍵點擊時的自動滾動行為
        svg.addEventListener("auxclick", (e) => {
          if (e.button === 1) {
            e.preventDefault();
          }
        });

        console.log("[DEBUG] Middle mouse pan initialized");
      }

      function handleMiddleMouseDown(e) {
        // 只處理滾輪中鍵（button === 1）
        if (e.button !== 1) return;

        e.preventDefault();
        e.stopPropagation();

        isMiddleMousePanning = true;
        middleMouseStartPos = {
          x: e.clientX,
          y: e.clientY,
        };

        // 獲取當前的 pan 位置
        if (panZoomInstance) {
          middleMouseStartPos.pan = panZoomInstance.getPan();
        }

        // 添加拖動游標樣式
        document.body.style.cursor = "grabbing";

        console.log(
          "[DEBUG] Middle mouse pan started at:",
          middleMouseStartPos
        );
      }

      function handleMiddleMouseMove(e) {
        if (!isMiddleMousePanning || !panZoomInstance) return;

        e.preventDefault();

        // 計算移動距離
        const dx = e.clientX - middleMouseStartPos.x;
        const dy = e.clientY - middleMouseStartPos.y;

        // 應用新的 pan 位置
        panZoomInstance.pan({
          x: middleMouseStartPos.pan.x + dx,
          y: middleMouseStartPos.pan.y + dy,
        });
      }

      function handleMiddleMouseUp(e) {
        if (!isMiddleMousePanning) return;

        // 只處理滾輪中鍵
        if (e.button !== 1) return;

        isMiddleMousePanning = false;
        middleMouseStartPos = null;

        // 恢復游標樣式
        document.body.style.cursor = "";

        console.log("[DEBUG] Middle mouse pan ended");
      }

      async function processE2k() {
        const statusDiv = document.getElementById("status");
        const mirrorModeToggle = document.getElementById("mirrorModeToggle");

        // [修改] 檢查是否已有預覽資料
        if (!previewFileContent || !previewJoints) {
          statusDiv.innerHTML = '<p class="error">請先點擊「預覽結構」按鈕</p>';
          return;
        }

        statusDiv.innerHTML = "<p>正在執行編號...</p>";
        fullProcessedBeams = [];

        try {
          // 使用預覽時已解析好的資料
          const fileContent = previewFileContent;
          const joints = previewJoints;

          let allBeamsAcrossStories = [];
          for (const story of availableStories) {
            const frames = parseFrames(fileContent, story);
            if (frames.length > 0) allBeamsAcrossStories.push(...frames);
          }
          if (allBeamsAcrossStories.length === 0)
            throw new Error("No qualifying beams found on any story.");

          fullDrawableBeams = allBeamsAcrossStories.map((f) => ({
            ...f,
            j1: joints[f.joint1],
            j2: joints[f.joint2],
          }));
          storyOrderInfo = availableStories.reduce((acc, story, index) => {
            acc[story] = index;
            return acc;
          }, {});

          const mainBeams = allBeamsAcrossStories.filter((b) => {
            const prop = b.prop.toUpperCase();
            const isNumericBeam = /^\d+(\.\d+)?B/.test(prop);
            return (
              (isNumericBeam ||
                prop.startsWith("B") ||
                prop.startsWith("G") ||
                prop.startsWith("FB") ||
                prop.startsWith("FGB")) &&
              !prop.startsWith("SB") &&
              !prop.startsWith("FSB") &&
              !prop.startsWith("WB") &&
              !prop.startsWith("FWB")
            );
          });
          const secondaryBeams = allBeamsAcrossStories.filter(
            (b) =>
              b.prop.toUpperCase().startsWith("SB") &&
              !b.prop.toUpperCase().startsWith("FSB")
          );
          const secondaryFoundationBeams = allBeamsAcrossStories.filter((b) =>
            b.prop.toUpperCase().startsWith("FSB")
          );
          const specialBeams = allBeamsAcrossStories
            .filter(
              (b) =>
                b.prop.toUpperCase().startsWith("WB") ||
                b.prop.toUpperCase().startsWith("FWB")
            )
            .map((b) => ({
              ...b,
              newLabel: "", // 不顯示編號
              isSpecialBeam: true, // 標記為特殊梁（WB/FWB）
            }));

          let allLabeledBeams = [...specialBeams];

          // [新增] 處理固定編號的梁
          const fixedLabelBeams = [];
          const reservedSerials = new Set(); // 記錄被固定編號佔用的序號（格式: "前綴:序號"，如 "g:1", "b:1"）

          if (
            document.getElementById("fixedLabelToggle").checked &&
            fixedLabelRules.length > 0
          ) {
            console.log("\n========== 處理固定編號梁 ==========");

            for (const story of availableStories) {
              // [修改] 包含所有梁類型（大梁和小梁都可以設定固定編號）
              const allBeamsInStory = allBeamsAcrossStories.filter(
                (b) => b.story === story
              );

              allBeamsInStory.forEach((beam) => {
                const beamSection = beam.prop.toLowerCase();
                const matchedRule = fixedLabelRules.find(
                  (rule) =>
                    beamSection.includes(rule.section) ||
                    beamSection === rule.section
                );

                if (matchedRule) {
                  const j1 = joints[beam.joint1];
                  const j2 = joints[beam.joint2];

                  if (j1 && j2) {
                    // [修改] 直接使用完整的固定編號（如 "g1", "b1"）
                    const newLabel = matchedRule.label;

                    // [修復] 根據 frame section (beam.prop) 判斷是大梁還是小梁
                    // 小梁：包含 SB 或 FSB 的斷面（支援 4sb、3.5sb 等格式）
                    // 大梁：其他所有斷面
                    const isSecondaryBeam =
                      beam.prop && /(\d+\.?\d*\s*)?(SB|FSB)/i.test(beam.prop);

                    fixedLabelBeams.push({
                      ...beam,
                      newLabel,
                      isFixedLabel: true,
                      isSecondaryBeam, // [新增] 標記是否為小梁（根據 section 判斷）
                    });

                    // [修改] 從完整編號中提取前綴和序號部分（如 "g1" → "g:1", "b2" → "b:2", "ga1" → "g:1"）
                    // 大梁前綴統一為 "g"（含 G, GA, GB, GC 等），小梁前綴統一為 "b"
                    const labelLower = matchedRule.label.toLowerCase();
                    const serialMatch = labelLower.match(/\d+$/);
                    if (serialMatch) {
                      // 判斷是大梁還是小梁的前綴
                      const prefixType = labelLower.startsWith("g") ? "g" : "b";
                      reservedSerials.add(`${prefixType}:${serialMatch[0]}`);
                    }

                    const beamType = isSecondaryBeam ? "小梁" : "大梁";
                    console.log(
                      `[${story}] ${beam.name} (${beam.prop}) → ${newLabel} [${beamType}]`
                    );
                  }
                }
              });
            }

            allLabeledBeams.push(...fixedLabelBeams);
            console.log(`✓ 共處理 ${fixedLabelBeams.length} 根固定編號梁`);
            console.log(
              `✓ 預留序號 (格式: 前綴:序號): ${Array.from(reservedSerials).join(
                ", "
              )}`
            );
            console.log("==========================================\n");
          }

          // [新增] 鏡像模式：使用智能偵測計算全域對稱軸
          let globalSymmetryAxisX = null;

          // [修正] 優先使用用戶自訂的對稱軸值，其次使用預先偵測的值
          // 移除方向限制，讓自訂值無論方向都能被應用
          if (mirrorModeToggle.checked) {
            if (
              userSymmetryAxisValue !== null &&
              userSymmetryAxisValue !== undefined
            ) {
              globalSymmetryAxisX = userSymmetryAxisValue;
              console.log(
                `\n[對稱軸] 使用自訂值 X = ${globalSymmetryAxisX.toFixed(3)}`
              );
            } else if (
              detectedSymmetryAxis?.value !== null &&
              detectedSymmetryAxis?.value !== undefined
            ) {
              globalSymmetryAxisX = detectedSymmetryAxis.value;
              console.log(
                `\n[對稱軸] 使用自動偵測值 X = ${globalSymmetryAxisX.toFixed(
                  3
                )}`
              );
            }
          }

          // 如果沒有預設值，才執行即時偵測
          if (
            globalSymmetryAxisX === null &&
            mirrorModeToggle.checked &&
            secondaryBeams.length > 0
          ) {
            console.log("\n========== 智能偵測全域對稱軸 ==========");
            const axisXCandidates = [];

            // 對每個樓層使用智能偵測
            for (const story of availableStories) {
              const secondaryBeamsInStory = secondaryBeams.filter(
                (b) => b.story === story
              );
              const mainBeamsInStory = mainBeams.filter(
                (b) => b.story === story
              );
              const allBeamsInStory = [
                ...secondaryBeamsInStory,
                ...mainBeamsInStory,
              ];

              if (allBeamsInStory.length < 10) continue;

              console.log(`\n[${story}] 智能偵測對稱軸...`);
              const detectedAxis = detectSymmetryAxis(
                allBeamsInStory,
                joints,
                gridData
              );

              if (detectedAxis) {
                axisXCandidates.push({ story, axisX: detectedAxis });
                console.log(`[${story}] ✓ 偵測成功`);
              } else {
                console.log(`[${story}] ✗ 未偵測到對稱結構`);
              }
            }

            // 找出最常出現的對稱軸（容許 ±0.5m 誤差）
            if (axisXCandidates.length > 0) {
              const AXIS_TOLERANCE = 0.5;
              const groups = [];

              axisXCandidates.forEach((candidate) => {
                let foundGroup = false;
                for (const group of groups) {
                  if (
                    Math.abs(group[0].axisX - candidate.axisX) < AXIS_TOLERANCE
                  ) {
                    group.push(candidate);
                    foundGroup = true;
                    break;
                  }
                }
                if (!foundGroup) {
                  groups.push([candidate]);
                }
              });

              // 選擇出現次數最多的群組
              groups.sort((a, b) => b.length - a.length);
              const bestGroup = groups[0];
              globalSymmetryAxisX =
                bestGroup.reduce((sum, c) => sum + c.axisX, 0) /
                bestGroup.length;

              console.log(
                `\n[全域對稱軸] X = ${globalSymmetryAxisX.toFixed(3)} (來自 ${
                  bestGroup.length
                } 個樓層)`
              );
              bestGroup.forEach((c) => console.log(`  - ${c.story}`));
            } else {
              console.log("\n[警告] 所有樓層都未偵測到對稱結構");
            }
            console.log("==========================================\n");
          }

          for (const story of availableStories) {
            const mainBeamsInStory = mainBeams.filter((b) => b.story === story);
            const secondaryBeamsInStory = secondaryBeams.filter(
              (b) => b.story === story
            );
            const secondaryFoundationBeamsInStory =
              secondaryFoundationBeams.filter((b) => b.story === story);

            if (mainBeamsInStory.length > 0) {
              // [修改] 排除已經被固定編號的梁
              const beamsToNumber = mainBeamsInStory.filter((beam) => {
                const beamKey = `${beam.name}|${beam.joint1}|${beam.joint2}`;
                return !fixedLabelBeams.some(
                  (fb) => `${fb.name}|${fb.joint1}|${fb.joint2}` === beamKey
                );
              });

              const labelComponentMap = generateLabelsForStory(
                beamsToNumber,
                joints,
                gridData,
                reservedSerials // [新增] 傳入預留的序號
              );

              // [修复] 处理所有大梁，包括没有被成功编号的梁
              beamsToNumber.forEach((originalBeam) => {
                const beamKey = `${originalBeam.name}|${originalBeam.joint1}|${originalBeam.joint2}`;
                const components = labelComponentMap.get(beamKey);

                let newLabel = "未編號"; // 默认标签

                if (components) {
                  // 如果成功编号
                  if (components.isDiagonal) {
                    // [修改] 斜向大梁的編號格式：與水平/垂直梁相同
                    const propUpper = originalBeam.prop.toUpperCase();
                    // 斜向梁的前綴：根據方向判斷
                    // isAlongX=true（沿X軸）→ 使用G（水平梁前綴）
                    // isAlongX=false（沿Y軸）→ 使用B（垂直梁前綴）
                    let prefix;
                    if (components.isAlongX) {
                      prefix = propUpper.startsWith("FB") ? "FG" : "G";
                    } else {
                      prefix = propUpper.startsWith("FB") ? "FB" : "B";
                    }

                    const finalPrefix = `${prefix}${components.primaryGridName.original || components.primaryGridName}${components.subGridMarker}`;
                    newLabel = `${finalPrefix}-${components.serial}`;
                  } else {
                    // 原有的水平/垂直梁編號邏輯
                    const propUpper = originalBeam.prop.toUpperCase();
                    const prefix = components.isVertical
                      ? propUpper.startsWith("FB")
                        ? "FB"
                        : "B"
                      : propUpper.startsWith("FB")
                      ? "FG"
                      : "G";

                    const finalPrefix = `${prefix}${components.primaryGridName.original || components.primaryGridName}${components.subGridMarker}`;
                    newLabel = `${finalPrefix}-${components.serial}`;
                  }
                }

                allLabeledBeams.push({
                  ...originalBeam,
                  newLabel,
                  isSecondaryBeam: false, // 大梁標記
                });
              });
            }

            if (secondaryBeamsInStory.length > 0) {
              // [新增] 排除已經被固定編號的小梁
              const secondaryBeamsToNumber = secondaryBeamsInStory.filter(
                (beam) => {
                  const beamKey = `${beam.name}|${beam.joint1}|${beam.joint2}`;
                  return !fixedLabelBeams.some(
                    (fb) => `${fb.name}|${fb.joint1}|${fb.joint2}` === beamKey
                  );
                }
              );

              const secondaryBeamLabels = generateSecondaryBeamLabels(
                secondaryBeamsToNumber,
                mainBeamsInStory,
                joints,
                "b",
                globalSymmetryAxisX,
                reservedSerials, // [新增] 傳入預留的序號
                gridData // [新增] 傳入格線資料以支援座標系統判斷
              );

              // [修复] 处理所有小梁，包括没有被成功编号的梁
              secondaryBeamsToNumber.forEach((originalBeam) => {
                const beamKey = `${originalBeam.name}|${originalBeam.joint1}|${originalBeam.joint2}`;
                const labelInfo = secondaryBeamLabels.get(beamKey);
                const newLabel = labelInfo ? labelInfo.newLabel : "b未編號";

                allLabeledBeams.push({
                  ...originalBeam,
                  newLabel,
                  isSecondaryBeam: true, // 小梁標記
                });
              });
            }

            if (secondaryFoundationBeamsInStory.length > 0) {
              // [新增] 排除已經被固定編號的基礎小梁
              const foundationBeamsToNumber =
                secondaryFoundationBeamsInStory.filter((beam) => {
                  const beamKey = `${beam.name}|${beam.joint1}|${beam.joint2}`;
                  return !fixedLabelBeams.some(
                    (fb) => `${fb.name}|${fb.joint1}|${fb.joint2}` === beamKey
                  );
                });

              const foundationBeamLabels = generateSecondaryBeamLabels(
                foundationBeamsToNumber,
                mainBeamsInStory,
                joints,
                "fb",
                globalSymmetryAxisX,
                reservedSerials, // [新增] 傳入預留的序號
                gridData // [新增] 傳入格線資料以支援座標系統判斷
              );

              // [修复] 处理所有基础小梁，包括没有被成功编号的梁
              foundationBeamsToNumber.forEach((originalBeam) => {
                const beamKey = `${originalBeam.name}|${originalBeam.joint1}|${originalBeam.joint2}`;
                const labelInfo = foundationBeamLabels.get(beamKey);
                const newLabel = labelInfo ? labelInfo.newLabel : "fb未編號";

                allLabeledBeams.push({
                  ...originalBeam,
                  newLabel,
                  isSecondaryBeam: true, // 基礎小梁標記
                });
              });
            }
          }

          let finalProcessedData = applySpecialPrefixRules(allLabeledBeams);
          // [修改] 允許特殊梁（WB/FWB）通過過濾，即使沒有編號
          finalProcessedData = finalProcessedData.filter(
            (beam) => beam.newLabel || beam.isSpecialBeam
          );

          finalProcessedData.sort((a, b) => {
            const storyCompare =
              storyOrderInfo[a.story] - storyOrderInfo[b.story];
            if (storyCompare !== 0) return storyCompare;

            // [修复] 使用 isSecondaryBeam 标记而不是基于编号的第一个字母
            const aIsSecondary = a.isSecondaryBeam || false;
            const bIsSecondary = b.isSecondaryBeam || false;

            if (aIsSecondary && !bIsSecondary) return 1;
            if (!aIsSecondary && bIsSecondary) return -1;

            return (a.newLabel || "").localeCompare(b.newLabel || "", "en", {
              numeric: true,
            });
          });

          fullProcessedBeams = finalProcessedData;

          // [新增] 清除標準層群組快取，讓下次編輯時重新計算
          invalidateStandardFloorGroupsCache();

          if (availableStories.includes("2F")) {
            storySelector.value = "2F";
          }
          handleStoryChange();

          // [修改] 顯示狀態訊息到控制列的內嵌區域
          showInlineStatus(
            `✅ 編號完成！共處理 ${fullProcessedBeams.length} 根梁`,
            "success"
          );
          if (fullProcessedBeams.length > 0) {
            exportBtn.disabled = false;
            exportJsonBtn.disabled = false;
          }
        } catch (error) {
          statusDiv.innerHTML = `<p class="error">Processing failed: ${error.message}</p>`;
          console.error(error);
        }
      }

      function populateStorySelector() {
        const selector = document.getElementById("storySelector");
        const fullscreenSelector = document.getElementById(
          "fullscreen-story-selector"
        );

        // 填充主選擇器
        selector.innerHTML = '<option value="all">All Floors</option>';
        availableStories.forEach((story) => {
          const option = document.createElement("option");
          option.value = story;
          option.textContent = story;
          selector.appendChild(option);
        });

        // 填充全螢幕選擇器
        fullscreenSelector.innerHTML =
          '<option value="all">All Floors</option>';
        availableStories.forEach((story) => {
          const option = document.createElement("option");
          option.value = story;
          option.textContent = story;
          fullscreenSelector.appendChild(option);
        });

        selector.disabled = false;
        document.getElementById("beamTypeSelector").disabled = false;
        // 【在最後一行後面加上】
        document.getElementById("mirrorModeToggle").disabled = false;
      }

      function handleStoryChange() {
        const storySelector = document.getElementById("storySelector");
        const beamTypeSelector = document.getElementById("beamTypeSelector");
        const selectedStory = storySelector.value;
        const selectedBeamType = beamTypeSelector.value;
        const svg = document.getElementById("drawing-svg");

        const storyDisplayName =
          selectedStory === "all" ? "All Floors Combined" : selectedStory;
        document.getElementById("plan-story-name").textContent =
          storyDisplayName;
        document.getElementById("fullscreen-story-name").textContent =
          storyDisplayName;
        // [新增] 更新全螢幕模式的浮動樓層 Bubble
        document.getElementById("fullscreen-floor-text").textContent =
          storyDisplayName;

        // 同步全螢幕選擇器
        document.getElementById("fullscreen-story-selector").value =
          selectedStory;

        let beamsToDisplay = fullProcessedBeams;
        let backgroundBeams = fullDrawableBeams;

        if (selectedStory !== "all") {
          beamsToDisplay = beamsToDisplay.filter(
            (b) => b.story === selectedStory
          );
          backgroundBeams = backgroundBeams.filter(
            (b) => b.story === selectedStory
          );
        }

        if (selectedBeamType === "main") {
          beamsToDisplay = beamsToDisplay.filter((b) => {
            if (!b.newLabel) return false;
            // [修复] 统一使用 isSecondaryBeam 标记来判断大梁/小梁
            // 大梁：isSecondaryBeam === false
            return !b.isSecondaryBeam;
          });
          backgroundBeams = backgroundBeams.filter(
            (b) => b.prop && !/SB/.test(b.prop.toUpperCase())
          );
        } else if (selectedBeamType === "secondary") {
          beamsToDisplay = beamsToDisplay.filter((b) => {
            if (!b.newLabel) return false;
            // [修复] 统一使用 isSecondaryBeam 标记来判断大梁/小梁
            // 小梁：isSecondaryBeam === true
            return b.isSecondaryBeam;
          });
          backgroundBeams = backgroundBeams.filter(
            (b) => b.prop && /SB/.test(b.prop.toUpperCase())
          );
        }

        // [優化] 保存當前的視圖狀態（使用相對座標，確保跨尺寸一致性）
        let savedViewState = null;
        if (panZoomInstance) {
          const sizes = panZoomInstance.getSizes();
          const pan = panZoomInstance.getPan();
          const zoom = panZoomInstance.getZoom();

          // 計算視圖中心點在 viewBox 中的相對位置（0-1 範圍）
          // 這樣在不同容器尺寸下都能保持相同的視覺位置
          const viewCenterX =
            (sizes.width / 2 - pan.x) / (sizes.viewBox.width * zoom);
          const viewCenterY =
            (sizes.height / 2 - pan.y) / (sizes.viewBox.height * zoom);

          savedViewState = {
            zoom: zoom,
            centerX: viewCenterX,
            centerY: viewCenterY,
          };

          try {
            panZoomInstance.destroy();
          } catch (e) {
            console.warn("[WARN] Failed to destroy panZoomInstance:", e);
          }
          panZoomInstance = null;
        }

        // [修改] 預覽模式：如果沒有編號資料，直接顯示所有梁（當作背景梁但用藍色顯示）
        const isPreviewMode =
          fullProcessedBeams.length === 0 && backgroundBeams.length > 0;

        const labeledBeamsWithCoords = beamsToDisplay.map((beam) => {
          const originalBeam = fullDrawableBeams.find(
            (b) =>
              b.name === beam.name &&
              b.story === beam.story &&
              b.joint1 === beam.joint1 &&
              b.joint2 === beam.joint2
          );
          return { ...beam, j1: originalBeam?.j1, j2: originalBeam?.j2 };
        });

        displayResults(
          labeledBeamsWithCoords,
          backgroundBeams,
          svg,
          gridData,
          isPreviewMode
        );

        // [新增] 套用已儲存的 Grid System 顯示狀態
        applyGridSystemVisibility();

        // [新增] 自動偵測對稱軸並繪製
        if (typeof autoDetectSymmetryAxis === "function") {
          autoDetectSymmetryAxis();
        }
        if (typeof drawSymmetryAxisLine === "function") {
          drawSymmetryAxisLine();
        }

        if (beamsToDisplay.length > 0 || gridData.x.length > 0) {
          // [優化] 只在首次創建時自動縮放，否則恢復之前的狀態
          const shouldFitAndCenter = savedViewState === null;

          // [修改] 移除 onZoom 回調中的字體動態調整
          // 改為使用 CSS 固定字體大小，縮放時字體會自然跟著縮放
          panZoomInstance = svgPanZoom("#drawing-svg", {
            panEnabled: false, // [修改] 禁用滑鼠拖動平移，只允許滾輪縮放
            zoomEnabled: true,
            dblClickZoomEnabled: true,
            mouseWheelZoomEnabled: true, // [新增] 明確啟用滾輪縮放
            controlIconsEnabled: true,
            fit: shouldFitAndCenter,
            center: shouldFitAndCenter,
            minZoom: 0.1,
            maxZoom: 50,
          });

          // [優化] 恢復之前保存的視圖狀態（使用相對座標計算新的 pan 值）
          if (!shouldFitAndCenter && savedViewState !== null) {
            // 使用 requestAnimationFrame 確保 DOM 已更新
            requestAnimationFrame(() => {
              const sizes = panZoomInstance.getSizes();
              const zoom = savedViewState.zoom;

              // 從相對座標計算新的 pan 值
              const newPanX =
                sizes.width / 2 -
                savedViewState.centerX * sizes.viewBox.width * zoom;
              const newPanY =
                sizes.height / 2 -
                savedViewState.centerY * sizes.viewBox.height * zoom;

              panZoomInstance.zoom(zoom);
              panZoomInstance.pan({ x: newPanX, y: newPanY });
            });
          }
        }
      }

      // ============ 全螢幕功能 ============

      function toggleFullscreen() {
        const drawingDiv = document.getElementById("drawing");
        const fullscreenIcon = document.getElementById("fullscreen-icon-top");
        const floorBubble = document.getElementById("fullscreen-floor-bubble");
        const htmlElement = document.documentElement;
        const bodyElement = document.body;

        console.log("=== toggleFullscreen 開始 ===");
        console.log(
          "當前全螢幕狀態:",
          drawingDiv.classList.contains("fullscreen")
        );

        if (drawingDiv.classList.contains("fullscreen")) {
          console.log("→ 離開全螢幕模式");

          // 離開全螢幕
          drawingDiv.classList.remove("fullscreen");
          if (fullscreenIcon) fullscreenIcon.textContent = "⛶";

          // [新增] 隱藏樓層 Bubble
          floorBubble.classList.remove("visible");

          // 恢復 html 和 body 的樣式
          htmlElement.style.padding = "";
          htmlElement.style.margin = "";
          htmlElement.style.overflow = "";
          htmlElement.style.background = "";
          bodyElement.style.padding = "";
          bodyElement.style.margin = "";
          bodyElement.style.overflow = "";
          bodyElement.style.background = "";

          // [優化] 重新調整 SVG，使用相對座標保持視覺位置一致
          if (panZoomInstance) {
            // 保存當前視圖狀態（使用相對座標）
            const sizes = panZoomInstance.getSizes();
            const pan = panZoomInstance.getPan();
            const zoom = panZoomInstance.getZoom();
            const viewCenterX =
              (sizes.width / 2 - pan.x) / (sizes.viewBox.width * zoom);
            const viewCenterY =
              (sizes.height / 2 - pan.y) / (sizes.viewBox.height * zoom);

            setTimeout(() => {
              console.log("→ 離開全螢幕：調整 SVG（保持位置）");
              panZoomInstance.resize();
              panZoomInstance.updateBBox();

              // 使用相對座標計算新的 pan 值
              requestAnimationFrame(() => {
                const newSizes = panZoomInstance.getSizes();
                const newPanX =
                  newSizes.width / 2 -
                  viewCenterX * newSizes.viewBox.width * zoom;
                const newPanY =
                  newSizes.height / 2 -
                  viewCenterY * newSizes.viewBox.height * zoom;
                panZoomInstance.zoom(zoom);
                panZoomInstance.pan({ x: newPanX, y: newPanY });
              });
            }, 100);
          }
        } else {
          console.log("→ 進入全螢幕模式");

          // [新增] 顯示樓層 Bubble
          floorBubble.classList.add("visible");

          // 進入全螢幕
          drawingDiv.classList.add("fullscreen");
          if (fullscreenIcon) fullscreenIcon.textContent = "✕";

          // 強制移除 html 和 body 的 padding/margin，並設定白色背景
          htmlElement.style.padding = "0";
          htmlElement.style.margin = "0";
          htmlElement.style.overflow = "hidden";
          htmlElement.style.background = "#ffffff";
          bodyElement.style.padding = "0";
          bodyElement.style.margin = "0";
          bodyElement.style.overflow = "hidden";
          bodyElement.style.background = "#ffffff";

          console.log("→ 設置 html/body 樣式完成");
          console.log("  html padding:", htmlElement.style.padding);
          console.log("  body padding:", bodyElement.style.padding);

          // 檢查 SVG 元素
          const svgElement = document.getElementById("drawing-svg");
          if (svgElement) {
            console.log("→ SVG 元素資訊:");
            console.log("  SVG clientWidth:", svgElement.clientWidth);
            console.log("  SVG clientHeight:", svgElement.clientHeight);
            console.log("  Window innerWidth:", window.innerWidth);
            console.log("  Window innerHeight:", window.innerHeight);
            console.log("  SVG viewBox:", svgElement.getAttribute("viewBox"));
          }

          // [優化] 進入全螢幕時，使用相對座標保持視覺位置一致
          if (panZoomInstance) {
            console.log("→ 開始調整 panZoomInstance...");

            // 保存當前視圖狀態（使用相對座標）
            const sizes = panZoomInstance.getSizes();
            const pan = panZoomInstance.getPan();
            const zoom = panZoomInstance.getZoom();
            const viewCenterX =
              (sizes.width / 2 - pan.x) / (sizes.viewBox.width * zoom);
            const viewCenterY =
              (sizes.height / 2 - pan.y) / (sizes.viewBox.height * zoom);

            // 使用 setTimeout 確保 DOM 更新完成
            setTimeout(() => {
              // 更新 SVG 尺寸
              panZoomInstance.resize();
              panZoomInstance.updateBBox();

              // 使用相對座標計算新的 pan 值
              requestAnimationFrame(() => {
                const newSizes = panZoomInstance.getSizes();
                const newPanX =
                  newSizes.width / 2 -
                  viewCenterX * newSizes.viewBox.width * zoom;
                const newPanY =
                  newSizes.height / 2 -
                  viewCenterY * newSizes.viewBox.height * zoom;
                panZoomInstance.zoom(zoom);
                panZoomInstance.pan({ x: newPanX, y: newPanY });

                console.log("  zoom:", zoom);
                console.log("  viewCenter:", {
                  x: viewCenterX,
                  y: viewCenterY,
                });
                console.log("=== toggleFullscreen 完成（保持位置）===");
              });
            }, 150);
          } else {
            console.warn("⚠️ panZoomInstance 不存在！");
          }
        }
      }

      function handleFullscreenStoryChange() {
        const fullscreenSelector = document.getElementById(
          "fullscreen-story-selector"
        );
        const mainSelector = document.getElementById("storySelector");

        // 同步到主選擇器
        mainSelector.value = fullscreenSelector.value;

        // 觸發主選擇器的變更事件
        handleStoryChange();
      }

      function previousFloor() {
        const selector = document.getElementById("storySelector");
        const currentIndex = selector.selectedIndex;

        if (currentIndex > 0) {
          selector.selectedIndex = currentIndex - 1;
          handleStoryChange();
        }
      }

      function nextFloor() {
        const selector = document.getElementById("storySelector");
        const currentIndex = selector.selectedIndex;

        if (currentIndex < selector.options.length - 1) {
          selector.selectedIndex = currentIndex + 1;
          handleStoryChange();
        }
      }

      // ============ 鍵盤快捷鍵 ============

      // 使用捕獲階段和 stopImmediatePropagation，確保最優先處理
      document.addEventListener(
        "keydown",
        function (event) {
          const drawingDiv = document.getElementById("drawing");
          const isFullscreen =
            drawingDiv && drawingDiv.classList.contains("fullscreen");

          // Ctrl+F - 最高優先級，立即攔截
          if (
            (event.ctrlKey || event.metaKey) &&
            (event.key === "f" || event.key === "F" || event.keyCode === 70)
          ) {
            event.preventDefault();
            event.stopImmediatePropagation();
            openSearchMemberDialog();
            return false;
          }

          // 上下鍵 - 在非輸入框時攔截
          const activeElement = document.activeElement;
          const isInputFocused =
            activeElement &&
            (activeElement.tagName === "INPUT" ||
              activeElement.tagName === "TEXTAREA" ||
              activeElement.tagName === "SELECT");

          if (
            !isInputFocused &&
            (event.key === "ArrowUp" ||
              event.key === "ArrowDown" ||
              event.keyCode === 38 ||
              event.keyCode === 40)
          ) {
            event.preventDefault();
            event.stopImmediatePropagation();

            if (event.key === "ArrowUp" || event.keyCode === 38) {
              previousFloor();
            } else if (event.key === "ArrowDown" || event.keyCode === 40) {
              nextFloor();
            }
            return false;
          }

          // ESC 鍵處理 - 先取消選取，再退出全螢幕
          if (event.key === "Escape" || event.keyCode === 27) {
            event.preventDefault();
            event.stopImmediatePropagation();

            // 優先取消選取
            if (selectedBeams && selectedBeams.size > 0) {
              clearAllSelections();
              updateBatchEditPanel(); // 更新批量編輯面板
              return false;
            }

            // 沒有選取時，退出全螢幕
            if (isFullscreen) {
              toggleFullscreen();
              return false;
            }
          }
        },
        true
      ); // 使用捕獲階段

      // ============================================



      function summarizeProperties(floorProps, storyOrder) {
        if (!floorProps || floorProps.length === 0) return "";

        const propsToFloorsMap = new Map();
        for (const { story, prop } of floorProps) {
          if (!propsToFloorsMap.has(prop)) {
            propsToFloorsMap.set(prop, []);
          }
          propsToFloorsMap.get(prop).push(story);
        }

        const summaryParts = [];
        propsToFloorsMap.forEach((floors, prop) => {
          const floorRange = summarizeFloors(floors, storyOrder);
          summaryParts.push(`${floorRange}: ${prop}`);
        });

        summaryParts.sort((a, b) => {
          const firstStoryA = a.split(":")[0].trim().split("~")[0];
          const firstStoryB = b.split(":")[0].trim().split("~")[0];
          return storyOrder[firstStoryA] - storyOrder[firstStoryB];
        });

        return summaryParts.join("; ");
      }

      function displayResults(
        labeledBeams,
        allBeams,
        svg,
        grids,
        isPreviewMode = false
      ) {
        const beamCoords = allBeams
          .flatMap((b) => [b.j1, b.j2])
          .filter(Boolean);
        if (beamCoords.length === 0 && (!grids || grids.x.length === 0)) {
          svg.innerHTML =
            '<text x="50%" y="50%" text-anchor="middle" fill="var(--theme-text-secondary)">No data to display</text>';
          return;
        }

        // [修改] 使用全局座標系統（基於所有樓層的梁），確保切換樓層時座標系統不變
        // 這樣切換樓層後，畫面位置（zoom 和 pan）可以保持一致
        const globalBeamCoords = fullDrawableBeams
          .flatMap((b) => [b.j1, b.j2])
          .filter(Boolean);
        const gridCoordsX = grids.x ? grids.x.map((g) => g.ordinate) : [];
        const gridCoordsY = grids.y ? grids.y.map((g) => g.ordinate) : [];

        // 使用全局梁座標來計算邊界（如果沒有全局數據，fallback 到當前樓層）
        const coordsForBounds =
          globalBeamCoords.length > 0 ? globalBeamCoords : beamCoords;
        const globalX = coordsForBounds.map((p) => p.x).concat(gridCoordsX);
        const globalY = coordsForBounds.map((p) => p.y).concat(gridCoordsY);
        const minX = Math.min(...globalX);
        const maxX = Math.max(...globalX);
        const minY = Math.min(...globalY);
        const maxY = Math.max(...globalY);

        const padding = 60;
        const svgWidth = svg.clientWidth || 1000;
        const svgHeight = svg.clientHeight || 800;
        const contentWidth = maxX - minX;
        const contentHeight = maxY - minY;

        let scale =
          Math.min(
            (svgWidth - 2 * padding) / (contentWidth || 1),
            (svgHeight - 2 * padding) / (contentHeight || 1)
          ) * 0.9;
        if (!isFinite(scale) || scale === 0) scale = 1;

        // [修正] 計算偏移量，使結構自動置中於畫布
        const scaledContentWidth = contentWidth * scale;
        const scaledContentHeight = contentHeight * scale;
        const offsetX = (svgWidth - scaledContentWidth) / 2;
        const offsetY = (svgHeight - scaledContentHeight) / 2;

        const transformX = (x) => offsetX + (x - minX) * scale;
        const transformY = (y) => svgHeight - offsetY - (y - minY) * scale;

        // [新增] 儲存轉換參數供對稱軸點選功能使用
        savedTransformParams = {
          scale,
          offsetX,
          offsetY,
          minX,
          minY,
          svgHeight,
        };

        // [優化] 使用 requestAnimationFrame 批量更新，減少重繪和閃爍
        // 先隱藏 SVG 內容，更新完成後再顯示
        svg.style.opacity = "0";

        // 清空內容
        svg.innerHTML = "";

        // 設定 viewBox 以支援 svg-pan-zoom 的 fit() 和 center() 功能
        // viewBox 定義 SVG 的座標系統，讓 svg-pan-zoom 能正確計算內容邊界
        svg.setAttribute("viewBox", `0 0 ${svgWidth} ${svgHeight}`);

        const allDrawableBeams = allBeams.filter((b) => b.j1 && b.j2);
        allDrawableBeams.forEach((beam) => {
          const line = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "line"
          );
          line.setAttribute("x1", transformX(beam.j1.x));
          line.setAttribute("y1", transformY(beam.j1.y));
          line.setAttribute("x2", transformX(beam.j2.x));
          line.setAttribute("y2", transformY(beam.j2.y));

          // 判斷是否為小梁（包含 SB 或 FSB 的斷面，支援 4sb、3.5sb 等格式）
          const isSecondaryBeam =
            beam.prop && /(\d+\.?\d*\s*)?(SB|FSB)/i.test(beam.prop);

          // 根據梁類型設定顏色類別
          if (isPreviewMode) {
            // 預覽模式：大梁用藍色，小梁用橘色
            line.setAttribute(
              "class",
              isSecondaryBeam ? "secondary-beam-line" : "labeled-beam-line"
            );
          } else {
            // 背景梁：統一灰色
            line.setAttribute("class", "beam-line");
          }
          svg.appendChild(line);
        });

        if (grids && grids.x && grids.y) {
          // [重構] 按 COORDSYSTEM 分組繪製 Grid Lines，並應用位置和旋轉變換
          const gridGroup = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "g"
          );
          gridGroup.setAttribute("class", "grid-lines");

          // 輔助函數：將局部座標轉換為全局座標（應用旋轉和平移）
          const localToGlobal = (localX, localY, coordSystem) => {
            const angleRad = (coordSystem.angle * Math.PI) / 180;
            const cosA = Math.cos(angleRad);
            const sinA = Math.sin(angleRad);

            // 旋轉 + 平移
            const globalX = coordSystem.ux + localX * cosA - localY * sinA;
            const globalY = coordSystem.uy + localX * sinA + localY * cosA;

            return { globalX, globalY };
          };

          // 繪製 X 軸 Grid Lines (垂直線)
          grids.x.forEach((gridLine) => {
            const coordSystemName = gridLine.coordsystem || "GLOBAL";
            const coordSystem = grids.coordSystems[coordSystemName] || {
              ux: 0,
              uy: 0,
              angle: 0,
            };

            const line = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "line"
            );

            // ordinate 是在局部座標系中 X 軸的值
            // 垂直線的兩個端點在局部座標系中是 (ordinate, minY) 和 (ordinate, maxY)
            const p1 = localToGlobal(gridLine.ordinate, minY, coordSystem);
            const p2 = localToGlobal(gridLine.ordinate, maxY, coordSystem);

            line.setAttribute("x1", transformX(p1.globalX));
            line.setAttribute("y1", transformY(p1.globalY));
            line.setAttribute("x2", transformX(p2.globalX));
            line.setAttribute("y2", transformY(p2.globalY));
            line.setAttribute("data-coordsystem", coordSystemName);
            line.classList.add("grid-line-element");

            gridGroup.appendChild(line);
          });

          // 繪製 Y 軸 Grid Lines (水平線)
          grids.y.forEach((gridLine) => {
            const coordSystemName = gridLine.coordsystem || "GLOBAL";
            const coordSystem = grids.coordSystems[coordSystemName] || {
              ux: 0,
              uy: 0,
              angle: 0,
            };

            const line = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "line"
            );

            // ordinate 是在局部座標系中 Y 軸的值
            // 水平線的兩個端點在局部座標系中是 (minX, ordinate) 和 (maxX, ordinate)
            const p1 = localToGlobal(minX, gridLine.ordinate, coordSystem);
            const p2 = localToGlobal(maxX, gridLine.ordinate, coordSystem);

            line.setAttribute("x1", transformX(p1.globalX));
            line.setAttribute("y1", transformY(p1.globalY));
            line.setAttribute("x2", transformX(p2.globalX));
            line.setAttribute("y2", transformY(p2.globalY));
            line.setAttribute("data-coordsystem", coordSystemName);
            line.classList.add("grid-line-element");

            gridGroup.appendChild(line);
          });

          svg.appendChild(gridGroup);

          // [新增] Grid Line 系統顏色配置和偏移設定
          const COORDSYSTEM_COLORS = {
            GLOBAL: "#4A90E2", // 藍色 - GLOBAL 系統
            O2: "#E24A4A", // 紅色
            A2: "#50C878", // 綠色
            A3: "#F39C12", // 橙色
            DEFAULT: "#9B59B6", // 紫色 - 其他系統
          };

          // [新增] 計算 COORDSYSTEM 的偏移距離（GLOBAL 最近，其他系統依序遞增）
          const getCoordSystemOffset = (coordsystem) => {
            const basePadding = padding / 2;
            const systemOrder = ["GLOBAL", "O2", "A2", "A3"];
            const index = systemOrder.indexOf(coordsystem);

            if (index === -1) {
              // 未知系統，使用最大偏移
              return basePadding + systemOrder.length * 30;
            }

            // GLOBAL: basePadding
            // O2: basePadding + 30
            // A2: basePadding + 60
            // A3: basePadding + 90
            return basePadding + index * 30;
          };

          // [新增] 獲取 COORDSYSTEM 的顏色
          const getCoordSystemColor = (coordsystem) => {
            return (
              COORDSYSTEM_COLORS[coordsystem] || COORDSYSTEM_COLORS["DEFAULT"]
            );
          };

          // ... 之後繪製網格氣泡 (grid bubble) 的程式碼維持不變 ...
          const gridLabelsGroup = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "g"
          );

          grids.x.forEach((gridLine) => {
            const loc = gridLine.bubbleLoc;
            const coordsystem = gridLine.coordsystem || "GLOBAL";
            const coordSystem = grids.coordSystems[coordsystem] || {
              ux: 0,
              uy: 0,
              angle: 0,
            };
            const offset = getCoordSystemOffset(coordsystem);
            const color = getCoordSystemColor(coordsystem);

            // [重構] 計算旋轉後的 grid line 端點位置
            const p1 = localToGlobal(gridLine.ordinate, minY, coordSystem); // bottom
            const p2 = localToGlobal(gridLine.ordinate, maxY, coordSystem); // top

            // 計算垂直於 grid line 的偏移方向（在旋轉座標系中，X軸格線是垂直的，偏移應該沿局部Y方向）
            const angleRad = (coordSystem.angle * Math.PI) / 180;
            const offsetDx = -offset * Math.sin(angleRad); // 沿局部Y軸正方向的X分量
            const offsetDy = offset * Math.cos(angleRad); // 沿局部Y軸正方向的Y分量

            const cx_top = transformX(p2.globalX) + offsetDx;
            const cy_top = transformY(p2.globalY) - offsetDy;
            const cx_bottom = transformX(p1.globalX) - offsetDx;
            const cy_bottom = transformY(p1.globalY) + offsetDy;

            // [修改] 根據 BUBBLELOC 決定顯示位置
            // X軸(垂直線): DEFAULT=上側(top), SWITCHED=下側(bottom)
            const showTop = !loc || loc.toUpperCase() === "DEFAULT";
            const showBottom =
              loc &&
              (loc.toUpperCase() === "SWITCHED" ||
                loc.toUpperCase() === "BOTH");

            if (showTop) {
              // [修改] 連接線從 Bubble 到旋轉後的 Grid Line 端點
              const topConnector = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "line"
              );
              topConnector.setAttribute("x1", cx_top);
              topConnector.setAttribute("y1", cy_top);
              topConnector.setAttribute("x2", transformX(p2.globalX));
              topConnector.setAttribute("y2", transformY(p2.globalY));
              topConnector.setAttribute("class", "grid-bubble-connector");
              topConnector.setAttribute("stroke", color);
              topConnector.setAttribute("data-coordsystem", coordsystem); // [新增]
              gridLabelsGroup.appendChild(topConnector);

              // [新增] 創建不可見的擴大點擊區域
              const topHitArea = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "circle"
              );
              topHitArea.setAttribute("cx", cx_top);
              topHitArea.setAttribute("cy", cy_top);
              topHitArea.setAttribute("r", INITIAL_GRID_BUBBLE_RADIUS + 5); // [修改] 輕微擴大半徑提供更好的點擊體驗
              topHitArea.setAttribute("class", "grid-bubble-hitarea draggable");
              topHitArea.setAttribute("data-coordsystem", coordsystem);
              topHitArea.setAttribute("fill", "rgba(255,255,255,0.01)"); // [修改] 使用實際透明色讓 fill 區域接收點擊
              topHitArea.setAttribute("stroke", "none"); // [修改] 不需要 stroke

              const topBubble = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "circle"
              );
              topBubble.setAttribute("cx", cx_top);
              topBubble.setAttribute("cy", cy_top);
              topBubble.setAttribute("r", INITIAL_GRID_BUBBLE_RADIUS);
              topBubble.setAttribute("class", "grid-bubble draggable"); // [修改] 加入 draggable class
              topBubble.setAttribute("stroke", color);
              topBubble.setAttribute("data-coordsystem", coordsystem);
              topBubble.setAttribute("pointer-events", "none"); // [新增] 讓實際的 bubble 不接收點擊事件，由 hitarea 處理

              const topText = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "text"
              );
              topText.setAttribute("x", cx_top);
              topText.setAttribute("y", cy_top);
              topText.setAttribute("class", "grid-bubble-text");
              topText.setAttribute("data-coordsystem", coordsystem); // [新增]
              topText.textContent = gridLine.name;

              gridLabelsGroup.appendChild(topBubble);
              gridLabelsGroup.appendChild(topText);
              gridLabelsGroup.appendChild(topHitArea); // [修改] 最後添加 hitarea，確保在最上層接收點擊事件
            }

            if (showBottom) {
              // [修改] 連接線從 Bubble 到旋轉後的 Grid Line 端點
              const bottomConnector = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "line"
              );
              bottomConnector.setAttribute("x1", cx_bottom);
              bottomConnector.setAttribute("y1", cy_bottom);
              bottomConnector.setAttribute("x2", transformX(p1.globalX));
              bottomConnector.setAttribute("y2", transformY(p1.globalY));
              bottomConnector.setAttribute("class", "grid-bubble-connector");
              bottomConnector.setAttribute("stroke", color);
              bottomConnector.setAttribute("data-coordsystem", coordsystem); // [新增]
              gridLabelsGroup.appendChild(bottomConnector);

              // [新增] 創建不可見的擴大點擊區域
              const bottomHitArea = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "circle"
              );
              bottomHitArea.setAttribute("cx", cx_bottom);
              bottomHitArea.setAttribute("cy", cy_bottom);
              bottomHitArea.setAttribute("r", INITIAL_GRID_BUBBLE_RADIUS + 5); // [修改] 輕微擴大半徑提供更好的點擊體驗
              bottomHitArea.setAttribute(
                "class",
                "grid-bubble-hitarea draggable"
              );
              bottomHitArea.setAttribute("data-coordsystem", coordsystem);
              bottomHitArea.setAttribute("fill", "rgba(255,255,255,0.01)"); // [修改] 使用實際透明色讓 fill 區域接收點擊
              bottomHitArea.setAttribute("stroke", "none"); // [修改] 不需要 stroke

              const bottomBubble = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "circle"
              );
              bottomBubble.setAttribute("cx", cx_bottom);
              bottomBubble.setAttribute("cy", cy_bottom);
              bottomBubble.setAttribute("r", INITIAL_GRID_BUBBLE_RADIUS);
              bottomBubble.setAttribute("class", "grid-bubble draggable"); // [修改] 加入 draggable class
              bottomBubble.setAttribute("stroke", color);
              bottomBubble.setAttribute("data-coordsystem", coordsystem);
              bottomBubble.setAttribute("pointer-events", "none");

              const bottomText = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "text"
              );
              bottomText.setAttribute("x", cx_bottom);
              bottomText.setAttribute("y", cy_bottom);
              bottomText.setAttribute("class", "grid-bubble-text");
              bottomText.setAttribute("data-coordsystem", coordsystem); // [新增]
              bottomText.textContent = gridLine.name;

              gridLabelsGroup.appendChild(bottomBubble);
              gridLabelsGroup.appendChild(bottomText);
              gridLabelsGroup.appendChild(bottomHitArea); // [修改] 最後添加 hitarea，確保在最上層接收點擊事件
            }
          });

          grids.y.forEach((gridLine) => {
            const loc = gridLine.bubbleLoc;
            const coordsystem = gridLine.coordsystem || "GLOBAL";
            const coordSystem = grids.coordSystems[coordsystem] || {
              ux: 0,
              uy: 0,
              angle: 0,
            };
            const offset = getCoordSystemOffset(coordsystem);
            const color = getCoordSystemColor(coordsystem);

            // [重構] 計算旋轉後的 grid line 端點位置
            const p1 = localToGlobal(minX, gridLine.ordinate, coordSystem); // left
            const p2 = localToGlobal(maxX, gridLine.ordinate, coordSystem); // right

            // 計算垂直於 grid line 的偏移方向（在旋轉座標系中，Y軸格線是水平的，偏移應該沿局部X方向）
            const angleRad = (coordSystem.angle * Math.PI) / 180;
            const offsetDx = -offset * Math.cos(angleRad); // 沿局部X軸負方向的X分量
            const offsetDy = -offset * Math.sin(angleRad); // 沿局部X軸負方向的Y分量

            const cx_left = transformX(p1.globalX) + offsetDx;
            const cy_left = transformY(p1.globalY) - offsetDy;
            const cx_right = transformX(p2.globalX) - offsetDx;
            const cy_right = transformY(p2.globalY) + offsetDy;

            // [修改] 根據 BUBBLELOC 決定顯示位置
            // Y軸(水平線): DEFAULT=左側(left), SWITCHED=右側(right)
            const showLeft = !loc || loc.toUpperCase() === "DEFAULT";
            const showRight =
              loc &&
              (loc.toUpperCase() === "SWITCHED" ||
                loc.toUpperCase() === "BOTH");

            if (showLeft) {
              // [修改] 連接線從 Bubble 到旋轉後的 Grid Line 端點
              const leftConnector = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "line"
              );
              leftConnector.setAttribute("x1", cx_left);
              leftConnector.setAttribute("y1", cy_left);
              leftConnector.setAttribute("x2", transformX(p1.globalX));
              leftConnector.setAttribute("y2", transformY(p1.globalY));
              leftConnector.setAttribute("class", "grid-bubble-connector");
              leftConnector.setAttribute("stroke", color);
              leftConnector.setAttribute("data-coordsystem", coordsystem); // [新增]
              gridLabelsGroup.appendChild(leftConnector);

              // [新增] 創建不可見的擴大點擊區域
              const leftHitArea = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "circle"
              );
              leftHitArea.setAttribute("cx", cx_left);
              leftHitArea.setAttribute("cy", cy_left);
              leftHitArea.setAttribute("r", INITIAL_GRID_BUBBLE_RADIUS + 5); // [修改] 輕微擴大半徑提供更好的點擊體驗
              leftHitArea.setAttribute(
                "class",
                "grid-bubble-hitarea draggable"
              );
              leftHitArea.setAttribute("data-coordsystem", coordsystem);
              leftHitArea.setAttribute("fill", "rgba(255,255,255,0.01)"); // [修改] 使用實際透明色讓 fill 區域接收點擊
              leftHitArea.setAttribute("stroke", "none"); // [修改] 不需要 stroke

              const leftBubble = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "circle"
              );
              leftBubble.setAttribute("cx", cx_left);
              leftBubble.setAttribute("cy", cy_left);
              leftBubble.setAttribute("r", INITIAL_GRID_BUBBLE_RADIUS);
              leftBubble.setAttribute("class", "grid-bubble draggable"); // [修改] 加入 draggable class
              leftBubble.setAttribute("stroke", color);
              leftBubble.setAttribute("data-coordsystem", coordsystem);
              leftBubble.setAttribute("pointer-events", "none");

              const leftText = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "text"
              );
              leftText.setAttribute("x", cx_left);
              leftText.setAttribute("y", cy_left);
              leftText.setAttribute("class", "grid-bubble-text");
              leftText.setAttribute("data-coordsystem", coordsystem); // [新增]
              leftText.textContent = gridLine.name;

              gridLabelsGroup.appendChild(leftBubble);
              gridLabelsGroup.appendChild(leftText);
              gridLabelsGroup.appendChild(leftHitArea); // [修改] 最後添加 hitarea，確保在最上層接收點擊事件
            }

            if (showRight) {
              // [修改] 連接線從 Bubble 到旋轉後的 Grid Line 端點
              const rightConnector = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "line"
              );
              rightConnector.setAttribute("x1", cx_right);
              rightConnector.setAttribute("y1", cy_right);
              rightConnector.setAttribute("x2", transformX(p2.globalX));
              rightConnector.setAttribute("y2", transformY(p2.globalY));
              rightConnector.setAttribute("class", "grid-bubble-connector");
              rightConnector.setAttribute("stroke", color);
              rightConnector.setAttribute("data-coordsystem", coordsystem); // [新增]
              gridLabelsGroup.appendChild(rightConnector);

              // [新增] 創建不可見的擴大點擊區域
              const rightHitArea = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "circle"
              );
              rightHitArea.setAttribute("cx", cx_right);
              rightHitArea.setAttribute("cy", cy_right);
              rightHitArea.setAttribute("r", INITIAL_GRID_BUBBLE_RADIUS + 5); // [修改] 輕微擴大半徑提供更好的點擊體驗
              rightHitArea.setAttribute(
                "class",
                "grid-bubble-hitarea draggable"
              );
              rightHitArea.setAttribute("data-coordsystem", coordsystem);
              rightHitArea.setAttribute("fill", "rgba(255,255,255,0.01)"); // [修改] 使用實際透明色讓 fill 區域接收點擊
              rightHitArea.setAttribute("stroke", "none"); // [修改] 不需要 stroke

              const rightBubble = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "circle"
              );
              rightBubble.setAttribute("cx", cx_right);
              rightBubble.setAttribute("cy", cy_right);
              rightBubble.setAttribute("r", INITIAL_GRID_BUBBLE_RADIUS);
              rightBubble.setAttribute("class", "grid-bubble draggable"); // [修改] 加入 draggable class
              rightBubble.setAttribute("stroke", color);
              rightBubble.setAttribute("data-coordsystem", coordsystem);
              rightBubble.setAttribute("pointer-events", "none");

              const rightText = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "text"
              );
              rightText.setAttribute("x", cx_right);
              rightText.setAttribute("y", cy_right);
              rightText.setAttribute("class", "grid-bubble-text");
              rightText.setAttribute("data-coordsystem", coordsystem); // [新增]
              rightText.textContent = gridLine.name;

              gridLabelsGroup.appendChild(rightBubble);
              gridLabelsGroup.appendChild(rightText);
              gridLabelsGroup.appendChild(rightHitArea); // [修改] 最後添加 hitarea，確保在最上層接收點擊事件
            }
          });
          svg.appendChild(gridLabelsGroup);

          // [新增] 初始化 Grid Bubble 拖曳功能
          initializeBubbleDragging();

          // [新增] 初始化梁標籤拖曳功能
          initializeBeamLabelDragging();

          // [新增] 初始化滾輪中鍵拖動畫布功能
          initializeMiddleMousePan();
        }
        // ... 之後繪製梁 (beam) 和標籤 (label) 的程式碼維持不變 ...
        const labeledDrawableBeams = labeledBeams.filter((b) => b.j1 && b.j2);
        labeledDrawableBeams.forEach((beam) => {
          // [新增] 建立唯一的梁識別 key（用於跨樓層選取）
          const beamKey = `${beam.story}|${beam.name}|${beam.joint1}|${beam.joint2}`;

          const line = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "line"
          );
          line.setAttribute("x1", transformX(beam.j1.x));
          line.setAttribute("y1", transformY(beam.j1.y));
          line.setAttribute("x2", transformX(beam.j2.x));
          line.setAttribute("y2", transformY(beam.j2.y));

          // [修改] 判斷梁的類別，WB/FWB 使用黑色
          let className = "labeled-beam-line"; // 預設：大梁藍色
          const isWallBeam =
            beam.isSpecialBeam ||
            beam.prop.toUpperCase().startsWith("WB") ||
            beam.prop.toUpperCase().startsWith("FWB");

          // [修復] 使用 frame section (beam.prop) 判斷是否為小梁，而不是 newLabel
          // 小梁：包含 SB 或 FSB 的斷面（支援 SB35X65、4sb、3.5sb 等格式）
          const isSecondaryBeam =
            beam.prop && /(\d+\.?\d*\s*)?(SB|FSB)/i.test(beam.prop);

          if (isWallBeam) {
            className = "wall-beam-line"; // WB/FWB 梁用黑色
          } else if (isSecondaryBeam) {
            className = "secondary-beam-line"; // 小梁用橘色
          }

          line.setAttribute("class", className);
          // [新增] 儲存梁資料到 data 屬性，用於點擊編輯和圈选
          line.dataset.beamName = beam.name;
          line.dataset.beamStory = beam.story;
          line.dataset.beamJoint1 = beam.joint1;
          line.dataset.beamJoint2 = beam.joint2;
          line.dataset.beamLabel = beam.newLabel || "";

          // [新增] 恢復選取狀態（支援跨樓層選取）
          if (selectedBeams.has(beamKey)) {
            line.classList.add("beam-selected");
          }

          // [修改] WB/FWB 梁不可點擊，不可編輯
          if (!isWallBeam) {
            line.style.cursor = "pointer";
          }

          // [新增] 右鍵顯示編號功能（保留給 WB/FWB 梁）
          line.addEventListener("contextmenu", (e) => {
            e.preventDefault();
            e.stopPropagation();
            showBeamInfo(e, beam);
          });

          svg.appendChild(line);

          // [修改] WB/FWB 梁不顯示編號標籤
          if (isWallBeam) {
            return; // 跳過標籤繪製
          }

          const text = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "text"
          );

          const textX = (transformX(beam.j1.x) + transformX(beam.j2.x)) / 2;
          const textY = (transformY(beam.j1.y) + transformY(beam.j2.y)) / 2;

          text.dataset.baseX = textX;
          text.dataset.baseY = textY;

          // [新增] 根據當前字體大小動態計算偏移距離
          const dynamicOffset = calculateOffset(currentFontSize);

          const isHorizontal = Math.abs(beam.j1.y - beam.j2.y) < TOLERANCE;
          const isVertical = Math.abs(beam.j1.x - beam.j2.x) < TOLERANCE;

          if (isHorizontal) {
            text.dataset.orientation = "horizontal";
            text.setAttribute("x", textX);
            text.setAttribute("y", textY + dynamicOffset);
            text.setAttribute("text-anchor", "middle"); // 水平置中
            text.setAttribute("dominant-baseline", "hanging"); // 文字頂部對齊，編號中線的頂點固定
          } else if (isVertical) {
            text.dataset.orientation = "vertical";
            const rotatedX = textX + dynamicOffset;
            text.setAttribute("x", rotatedX);
            text.setAttribute("y", textY);
            text.setAttribute("text-anchor", "middle"); // 保持中線對齊
            text.setAttribute("dominant-baseline", "hanging"); // 旋轉後從梁向外延伸
            text.setAttribute(
              "transform",
              `rotate(-90, ${rotatedX}, ${textY})`
            );
          } else {
            text.dataset.orientation = "angled";
            const x1_svg = transformX(beam.j1.x);
            const y1_svg = transformY(beam.j1.y);
            const x2_svg = transformX(beam.j2.x);
            const y2_svg = transformY(beam.j2.y);
            let angle =
              (Math.atan2(y2_svg - y1_svg, x2_svg - x1_svg) * 180) / Math.PI;

            if (angle > 90 || angle < -90) {
              angle += 180;
            }

            text.setAttribute("x", textX);
            text.setAttribute("y", textY - dynamicOffset); // 使用動態偏移
            text.setAttribute("text-anchor", "middle"); // 水平置中
            text.setAttribute("dominant-baseline", "alphabetic"); // 基線對齊
            text.setAttribute(
              "transform",
              `rotate(${angle}, ${textX}, ${textY - dynamicOffset})` // 旋轉中心調整
            );
          }

          text.setAttribute("class", "beam-label");
          text.setAttribute("font-size", currentFontSize); // [新增] 使用當前字體大小
          text.textContent = beam.newLabel;
          // [新增] 为标签添加 dataset 以支持圈选
          text.dataset.beamName = beam.name;
          text.dataset.beamLabel = beam.newLabel; // 保存編號用於右鍵顯示
          text.dataset.beamProp = beam.prop || ""; // 保存 section
          text.dataset.beamStory = beam.story || ""; // 保存樓層
          text.dataset.beamJoint1 = beam.joint1; // [新增] 保存節點資訊用於精確匹配
          text.dataset.beamJoint2 = beam.joint2; // [新增] 保存節點資訊用於精確匹配

          // [新增] 恢復選取狀態（支援跨樓層選取）
          if (selectedBeams.has(beamKey)) {
            text.classList.add("beam-selected");
          }

          // [新增] 標籤也可點擊（现在由圈选功能处理）
          text.style.cursor = "move"; // [修改] 改為 move 游標表示可拖動

          // 不再應用儲存的偏移量，標籤總是回到原始位置
          // 注释掉原有的点击编辑功能，改由圈选功能处理
          // text.addEventListener("click", () => openBeamEditDialog(beam));

          // [新增] 右鍵顯示編號功能
          text.addEventListener("contextmenu", (e) => {
            e.preventDefault();
            e.stopPropagation();
            showBeamInfo(e, beam);
          });

          svg.appendChild(text);
        });

        // [優化] 繪製完成後恢復顯示，使用 requestAnimationFrame 確保平滑過渡
        requestAnimationFrame(() => {
          svg.style.opacity = "1";
          svg.style.transition = "opacity 0.15s ease-out";
        });
      }

      // [已模組化] pointToLineDistance 已移至 js/utils/geometry.js
      // 由 main.js 掛載到 window.pointToLineDistance

      // [新增] 查找最近的梁
      function findNearestBeam(event, maxDistance = 20) {
        const svgElement = document.getElementById("svg-container");
        if (!svgElement) return null;

        // 獲取點擊位置的 SVG 座標
        const pt = svgElement.createSVGPoint();
        pt.x = event.clientX;
        pt.y = event.clientY;

        const viewport = getViewportElement();
        const ctm = viewport.getScreenCTM
          ? viewport.getScreenCTM()
          : svgElement.getScreenCTM();
        const svgPt = pt.matrixTransform(ctm.inverse());

        // 搜索所有梁線（包括 WB/FWB 梁和小梁）
        const beamLines = svgElement.querySelectorAll(
          ".labeled-beam-line, .secondary-beam-line, .special-beam-line, .wall-beam-line"
        );
        let nearestBeam = null;
        let minDistance = maxDistance;

        beamLines.forEach((line) => {
          const x1 = parseFloat(line.getAttribute("x1"));
          const y1 = parseFloat(line.getAttribute("y1"));
          const x2 = parseFloat(line.getAttribute("x2"));
          const y2 = parseFloat(line.getAttribute("y2"));

          const distance = pointToLineDistance(
            svgPt.x,
            svgPt.y,
            x1,
            y1,
            x2,
            y2
          );

          if (distance < minDistance) {
            minDistance = distance;
            nearestBeam = {
              name: line.dataset.beamName,
              newLabel: line.dataset.beamLabel,
              prop: line.dataset.beamProp,
              story: line.dataset.beamStory,
            };
          }
        });

        return nearestBeam;
      }

      // [新增] 右鍵顯示梁資訊
      function showBeamInfo(event, beam) {
        // [修改] 從 fullProcessedBeams 中查找最新的梁數據
        const latestBeam = fullProcessedBeams.find(
          (b) =>
            b.name === beam.name &&
            b.story === beam.story &&
            b.joint1 === beam.joint1 &&
            b.joint2 === beam.joint2
        );

        // 使用最新的梁數據，如果找不到則使用傳入的 beam
        const beamData = latestBeam || beam;

        // 移除舊的提示框（如果有）
        const oldTooltip = document.getElementById("beam-info-tooltip");
        if (oldTooltip) {
          oldTooltip.remove();
        }

        // 創建新的提示框
        const tooltip = document.createElement("div");
        tooltip.id = "beam-info-tooltip";
        tooltip.style.position = "fixed";
        tooltip.style.left = event.clientX + 10 + "px";
        tooltip.style.top = event.clientY + 10 + "px";
        tooltip.style.background = "var(--theme-surface)";
        tooltip.style.border = "2px solid var(--theme-accent)";
        tooltip.style.borderRadius = "8px";
        tooltip.style.padding = "12px 16px";
        tooltip.style.zIndex = "10000";
        tooltip.style.boxShadow = "0 4px 12px rgba(0,0,0,0.3)";
        tooltip.style.fontSize = "14px";
        tooltip.style.lineHeight = "1.6";
        tooltip.style.minWidth = "200px";
        tooltip.style.color = "var(--theme-text-primary)";

        // 判斷是否為小梁
        const isSecondary =
          beamData.prop && /(\d+\.?\d*\s*)?(SB|FSB)/i.test(beamData.prop);
        const beamType = isSecondary ? "小梁" : "大梁";
        const beamTypeColor = isSecondary ? "#f97316" : "#3b82f6";

        tooltip.innerHTML = `
          <div style="margin-bottom: 4px;">
            <strong>編號：</strong><span style="color: var(--theme-accent); font-weight: bold;">${
              beamData.newLabel || beamData.name
            }</span>
          </div>
          <div style="margin-bottom: 4px;">
            <strong>ETABS編號：</strong>${beamData.name}
          </div>
          <div style="margin-bottom: 4px;">
            <strong>斷面：</strong>${beamData.prop || "N/A"}
          </div>
          <div style="margin-bottom: 4px;">
            <strong>樓層：</strong>${beamData.story || "N/A"}
          </div>
          <div>
            <strong>類型：</strong><span style="color: ${beamTypeColor}; font-weight: bold;">${beamType}</span>
          </div>
        `;

        document.body.appendChild(tooltip);

        // 點擊任意處關閉
        const closeTooltip = () => {
          tooltip.remove();
          document.removeEventListener("click", closeTooltip);
          document.removeEventListener("contextmenu", closeTooltip);
        };

        setTimeout(() => {
          document.addEventListener("click", closeTooltip);
          document.addEventListener("contextmenu", closeTooltip);
        }, 100);
      }

      // [新增] 開啟梁編輯對話框
      // [修改] 開啟梁編輯對話框
      function openBeamEditDialog(beam) {
        currentEditingBeam = beam;
        document.getElementById("edit-etabs-name").value = beam.name;
        document.getElementById("edit-story").value = beam.story;

        const newLabelInput = document.getElementById("edit-new-label");
        newLabelInput.value = beam.newLabel || "";

        // [新增] 檢查是否屬於標準層群組，顯示/隱藏連動選項
        const standardFloorGroup = getStandardFloorGroupForStory(beam.story);
        const linkGroup = document.getElementById("link-standard-floor-group");
        const linkCheckbox = document.getElementById("link-standard-floor");

        if (standardFloorGroup && standardFloorGroup.length > 1) {
          linkGroup.style.display = "block";
          linkCheckbox.checked = true; // 預設勾選
        } else {
          linkGroup.style.display = "none";
        }

        document.getElementById("beam-edit-dialog").style.display = "block";
        document.getElementById("dialog-overlay").style.display = "block";
        // 防止背景滾動
        document.body.style.overflow = "hidden";

        // 自動對焦並選取文字
        newLabelInput.focus();
        newLabelInput.select();
      }
      // [新增] 關閉梁編輯對話框
      function closeBeamEditDialog() {
        currentEditingBeam = null;
        document.getElementById("beam-edit-dialog").style.display = "none";
        document.getElementById("dialog-overlay").style.display = "none";
        // 恢復背景滾動
        document.body.style.overflow = "";
      }

      // [新增] 儲存梁編號編輯
      function saveBeamEdit() {
        if (!currentEditingBeam) return;

        const newLabel = document.getElementById("edit-new-label").value.trim();
        if (!newLabel) {
          alert("請輸入新的編號");
          return;
        }

        // [新增] 檢查是否勾選連動標準層
        const linkCheckbox = document.getElementById("link-standard-floor");
        const linkGroup = document.getElementById("link-standard-floor-group");
        const shouldLinkStandardFloors =
          linkGroup.style.display !== "none" && linkCheckbox.checked;

        // 更新 fullProcessedBeams 中的資料
        const beamIndex = fullProcessedBeams.findIndex(
          (b) =>
            b.name === currentEditingBeam.name &&
            b.story === currentEditingBeam.story &&
            b.joint1 === currentEditingBeam.joint1 &&
            b.joint2 === currentEditingBeam.joint2
        );

        if (beamIndex !== -1) {
          const oldLabel = fullProcessedBeams[beamIndex].newLabel;
          fullProcessedBeams[beamIndex].newLabel = newLabel;

          // [新增] 連動標準層更新
          if (shouldLinkStandardFloors) {
            const standardFloorGroup = getStandardFloorGroupForStory(
              currentEditingBeam.story
            );
            if (standardFloorGroup && standardFloorGroup.length > 1) {
              const linkedBeams = findBeamsAtSamePosition(
                fullProcessedBeams[beamIndex],
                standardFloorGroup
              );
              console.log(
                `[連動標準層] 更新 ${linkedBeams.length} 個其他樓層的梁`
              );
              linkedBeams.forEach((linkedBeam) => {
                linkedBeam.newLabel = newLabel;
              });
            }
          }

          // [新增] 自動更新連續小梁編號
          updateSequentialBeamLabels(
            oldLabel,
            newLabel,
            currentEditingBeam.story
          );

          // 重新繪製
          handleStoryChange();
          closeBeamEditDialog();
          // [移除] 不再顯示 alert 提示
        }
      }









      // 檔案選擇時更新檔名顯示並自動預覽
      document
        .getElementById("e2kFile")
        .addEventListener("change", function (event) {
          const fileNameDisplay = document.getElementById("fileName");
          if (event.target.files.length > 0) {
            fileNameDisplay.textContent = event.target.files[0].name;
            // 自動預覽結構
            if (typeof previewFile === 'function') {
                previewFile();
            } else {
                console.error("previewFile function not found");
            }
          } else {
            fileNameDisplay.textContent = "尚未選擇檔案";
          }
        });

      // [新增] 頁面載入時初始化固定編號規則
      // 確保在 main.js 模組載入後執行
      document.addEventListener("DOMContentLoaded", function() {
        if (typeof loadFixedLabelRules === 'function') loadFixedLabelRules();
        if (typeof updateFixedLabelSummary === 'function') updateFixedLabelSummary();
        if (typeof updateFixedLabelButtonState === 'function') updateFixedLabelButtonState();
      });

      // ============================================
      // 圈選功能實現 (SVG 內部座標系統)
      // ============================================


      // ============ 搜尋桿件功能 ============


      // 在繪圖完成后初始化圈選功能
      // 需要在 displayResults 函數調用後執行
      const originalDisplayResults = displayResults;
      displayResults = function (...args) {
        originalDisplayResults.apply(this, args);
        // 延迟初始化以确保SVG元素已经渲染
        setTimeout(() => {
          initializeSelectionFeature();
          initializeMiddleMousePan(); // [新增] 初始化滾輪中鍵拖動
        }, 100);
      };

      // ============ 全局鍵盤快捷鍵（頁面載入時就生效）============
      // 添加全局鍵盤事件監聽器，攔截 Ctrl+F 快捷鍵
      document.addEventListener(
        "keydown",
        function (evt) {
          // 攔截 Ctrl+F 或 Cmd+F
          if ((evt.ctrlKey || evt.metaKey) && evt.key === "f") {
            evt.preventDefault(); // 防止瀏覽器預設的搜尋功能
            openSearchMemberDialog();
          }
          // 攔截 Escape 關閉搜尋對話框
          else if (evt.key === "Escape") {
            if (
              document.getElementById("search-member-dialog").style.display ===
              "block"
            ) {
              evt.preventDefault();
              closeSearchMemberDialog();
            }
          }
        },
        true
      ); // 使用捕獲階段，確保優先攔截

      // [新增] 頁面載入時的初始化檢查
      document.addEventListener("DOMContentLoaded", function () {
        console.log("[DEBUG] DOM Content Loaded");

        // 檢查關鍵元素是否存在
        const fileInput = document.getElementById("e2kFile");
        const statusDiv = document.getElementById("status");
        const drawingSvg = document.getElementById("drawing-svg");

        console.log("[DEBUG] Element check:", {
          fileInput: !!fileInput,
          statusDiv: !!statusDiv,
          drawingSvg: !!drawingSvg,
        });

        // 檢查 previewFile 函數是否存在
        if (typeof previewFile === "function") {
          console.log("[DEBUG] previewFile function is defined");
        } else {
          console.error("[ERROR] previewFile function is not defined!");
        }
      });
    </script>

    <!-- [新增] 全螢幕模式樓層顯示 Bubble（浮動在最上層，不在畫布上） -->
    <div id="fullscreen-floor-bubble">
      <span id="fullscreen-floor-text">所有樓層合併</span>
    </div>
  </body>
</html>
